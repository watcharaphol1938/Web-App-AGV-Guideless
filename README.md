# Web-App-AGV-Guideless

# Laptop
- Dell XPS 15
  - https://www.dell.com/en-th/shop/sfc/sf/xps-laptops#models-module
- ASUS ROG Zephyrus S GX701
  - https://www.asus.com/th/laptops/for-gaming/rog-republic-of-gamers/filter?SubSeries=ROG-Zephyrus
- Lenovo ThinkPad X1 Extreme Gen 3
  - https://www.lenovo.com/th/th/laptops/thinkpad/thinkpad-x1/c/thinkpad-x1-series#compareSection
# PC
- HP Z840 Workstation
  - https://www.hp.com/th-th/shop/desktops/business-desktops/z-workstations.html
- Dell Precision 7920 Tower Workstation
  - https://www.dell.com/en-th/shop/sfc/sf/precision-desktops
  - https://www.dell.com/en-th/shop/workstations/precision-7920-tower/spd/precision-7920-workstation
- Lenovo ThinkStation P920

# microcontroller
  https://micro.ros.org/docs/overview/hardware/
  https://www.allonrobots.com/robot-microcontroller/
  https://jakobfriedl.tech/microcontrollers-in-robotics
  https://www.generationrobots.com/en/326-microcontrollers-and-development-boards
  https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/jetson-nano-developer-kit/

# single-board computer
https://all3dp.com/1/single-board-computer-raspberry-pi-alternative/
https://www.electromaker.io/blog/article/best-single-board-computer-for-robotics#:~:text=The%20Best%20Single-Board%20Computer%20for%20Robotics%20-%20Best,for%20Robotics%205%205.%20ASUS%20Tinker%20Board%20S

# LiDAR
https://www.usgs.gov/ngp-standards-and-specifications/lidar-base-specification-tables
https://www.blickfeld.com/blog/understanding-lidar-specifications/
https://www.researchgate.net/figure/Lidar-System-Specifications_tbl1_51735167
https://www.sick.com/us/en/lidar-sensors/3d-lidar-sensors/multiscan100/multiscan136-1/p/p673512

# camera 3D
https://www.researchgate.net/figure/3D-cameras-specifications_tbl1_269323833
https://ark.intel.com/content/www/us/en/ark/compare.html?productIds=123692,123721,126367,128255,128256,128257,190004,192742,201775,205847,212558,212559,212561,229218,229219,229673,230571,233194,92329,98316,98319,98320,99403

# IMU
https://www.vectornav.com/resources/inertial-navigation-primer/specifications--and--error-budgets/specs-imuspecs
https://www.researchgate.net/figure/Specifications-of-typical-inertial-measurement-units-IMUS_tbl1_281049459
https://support.sbg-systems.com/sc/el/latest/documentations-resources/ellipse-documentation/performance-specifications/raw-imu-specifications
https://www.advancednavigation.com/tech-articles/inertial-measurement-unit-imu-an-introduction/#interpreting
https://www.bosch-sensortec.com/media/boschsensortec/downloads/product_flyer/bst-bmi088-fl000.pdf
https://www.bosch-sensortec.com/products/motion-sensors/imus/bmi088/

# motor driver
https://www.geeetech.com/wiki/index.php/L298N_Motor_Driver_Board
https://www.etechnophiles.com/l293d-vs-l298n-motor-driver-differences-specifications-and-pinouts/
https://www.ti.com/product/DRV8871
https://www.globalspec.com/specsearch/searchform/motion_controls/controls_drives/dc_motor_drives
https://components101.com/modules/l293n-motor-driver-module
https://www.moonsindustries.com/p/m2dc-series-servo-drives/m2dc-6d05s-000004696351002294

# encoder
https://www.tamagawa-seiki.com/products/rotaryencoder/absolute-multiturn.html
file:///C:/Users/jeans/Downloads/L-9517-9934-01-A_Data_sheet_FORTiS-S_EN.pdf
https://www.quantumdev.com/wp-content/uploads/2018/07/QM35-EZComm.pdf
https://www.encoder.com/product-datasheets
https://assets.omron.eu/downloads/datasheet/en/v3/e6c3-c_rugged_incremental_rotary_encoder_datasheet_en.pdf
https://www.globalspec.com/specsearch/searchform/sensors_transducers_detectors/encoders_resolvers/rotary_encoders
https://www.ia.omron.com/products/family/487/specification.html
https://www.encoder.com/hubfs/products/Model_A25SB/datasheet_model-a25sb.pdf?hsLang=en
https://www.sensata.com/sites/default/files/a/sensata-dual%20encoder-usb%20converter-datasheet.pdf

# battery
https://www.iotforall.com/best-battery-for-robot#:~:text=So%2C%20let%E2%80%99s%20now%20specify%20the%20requirements%20for%20the,so%20the%20required%20capacity%20is%20500mAh.%20More%20items
https://www.generationrobots.com/en/402876-batterie-lipo-111v-1800mah-lb-012.html
https://www.generationrobots.com/en/307-batteries-for-robots
https://www.lithium-battery-factory.com/product/agv-lithium-batteries-24v-60ah/
https://www.ia.omron.com/products/family/3664/specification.html
https://bs-battery.com/wp-content/uploads/2021/11/BSH-HU05_NIMH_LawnGarden_2021.pdf
https://fulbat.com/product/fh-hu05/

# web app
https://budibase.com/blog/how-to-make-a-web-app/
https://unique-dev.net/login.aspx?cmd=0
https://www.chartjs.org/docs/latest/getting-started/usage.html
https://www.youtube.com/watch?v=XTqFjRlwMXA&t=4449s
https://www.youtube.com/watch?v=FJDVKeh7RJI
https://stackoverflow.com/questions/10461257/an-attempt-was-made-to-access-a-socket-in-a-way-forbidden-by-its-access-permissi
https://appuals.com/fix-an-attempt-was-made-to-access-a-socket-in-a-way-forbidden-by-its-access-permissions/
https://www.techinpost.com/an-attempt-was-made-to-access-a-socket-in-a-way-forbidden-by-its-access-permissions/
    - Tools
        - Node JS
        - VS Code
            - Vetur
            - AutoRename Tag
            - Color Hilight
            - Prettier Code Formatter
            - Live Server (optional)
        - Vue JS devtools
        - Vue CLI
        - Vue CLI
    - Backend
        - sqlalchemy in flask
            - https://www.youtube.com/watch?v=FEyNt9iFPGc&list=PLXmMXHVSvS-BlLA5beNJojJLlpE0PJgCW&index=2
            - https://www.youtube.com/playlist?list=PLLXm9VyNhEPQ5mmnaRNPsoAW-GpPnEONO
            - https://www.youtube.com/watch?v=AKQ3XEDI9Mw
        - pip install sqlalchemy
    - Frontend
        - Vue js
            - https://www.youtube.com/watch?v=F7PLPJqVotk&list=PL4cUxeGkcC9hYYGbV60Vq3IXYNfDk8At1&index=2
        - node js
        - npm install -g @vue/cli
        - vue create project
        - vue create reaction-timer
        - vue create web-form
        - vue create ninja-jobs
        - npm install json-server
        - json-server --watch data/db.json
    - Example
        - https://www.youtube.com/watch?v=msEmUtYqVV0
        - https://herbzhao.medium.com/vue-js-flask-flask-sqlalchemy-6a85a67a7790
        - https://www.youtube.com/watch?v=nCMB5p74WJQ

# laptop
https://www.bnn.in.th/th/p/notebook/notebook-by-brands/hp-notebook-by-brands?in_stock=true&sort_by=relevance&page=1&attributes=processor%3Aintel-core-i7-12700h
https://www.bnn.in.th/th/p/notebook/notebook-by-brands/asus-notebook-by-brands?in_stock=true&sort_by=relevance&page=1&attributes=processor%3Aintel-core-i7-12700h
https://www.bnn.in.th/th/p/notebook/notebook-by-brands/acer-notebook-by-brands?in_stock=true&attributes=processor%3Aintel-core-i7-13700hx&sort_by=relevance&page=1
https://www.bnn.in.th/th/p/notebook/notebook-by-brands/msi-notebook-by-brands?in_stock=true&sort_by=relevance&page=1&attributes=processor%3Aintel-core-i7-13700h
https://www.bnn.in.th/th/p/notebook/notebook-by-brands/lenovo-notebook-by-brands?in_stock=true&sort_by=relevance&page=1&attributes=processor%3Aintel-core-i7-12700h

# anydesk
https://blog.limitrack.com/howto-anydesk/

# country list of DENSO
- Eatern Asia
    1.  China
        1. Chongqing Chaoli Electric Appliance Co., Ltd.
            - Development, Production and Sale of the thermal Products (HVAC, Heat Exchanger, AC plumbing, etc.)
        2. DENSO AIR SYSTEMS TIANJIN CO., LTD.
            - Manufacture and sale of hoses and pipes for car air conditioners
        3. DENSO (CHANGZHOU) FUEL INJECTION SYSTEM CO., LTD.
            - Manufacture and sale of diesel fuel pump, electronic diesel fuel injection system, gasoline fuel direct injection pump
        4. DENSO FA SHANGHAI CO., LTD
            - Design, manufacture, various machining operations, sales and marketing of automated equipment and production lines. Technology development and technical consulting. Real estate leasing
        5. DENSO (GUANGZHOU NANSHA) CO., LTD.
            - Manufacture and sale of automotive powertrain products, motors, and electronics products, and their parts.
        6. DENSO KOTEI AUTOMOTIVE ELECTRONICS (WUHAN) CO., LTD
            - Development, design, manufacture, sale, wholesale, export and import of automotive cockpit display products, automotive electronics products and their materials and components
        7. DENSO MANUFACTURING (HANGZHOU) CO., LTD.
            - Manufacture and sale of motor components
        8. DENSO MANUFACTURING (TIANJIN) MOTOR CO., LTD.
            - Manufacture and sale of automotive small motors
        9. DENSO TEN ELECTRONICS (WUXI) Limited
            - Manufacture of audiovisual products
        10. DENSO TEN PRECISION ELECTRONICS (TIANJIN) Limited
            - Molding and processing of resin parts for automobiles
        11. DENSO (TIANJIN) BODY PARTS CO., LTD.
            - Manufacture and sale of instrument clusters
        12. DENSO (TIANJIN) THERMAL PRODUCTS CO., LTD.
            - Manufacture and sale of heat exchangers for air-conditioners, radiators and automotive filters.
        13. GONGCHENG DENSO (CHONGQING) CO., LTD
            - Manufacture and sales of motorcycle parts
        14. GUANGZHOU DENSO CO., LTD.
              - Manufacture and sales
                - automotive air conditioners
                - radiators
        15. Liuzhou Chaoli Car Parts Manufacturing Co., Ltd.
              - Manufacture and sale of heat-related products
        16. Nanjing Voaasco Auto Parts Co., Ltd.
              - Manufacture and sale of heat-related products
        17. Ningbo Hangzhou Bay New District Chaoli Auto Parts Manufacturing Co., Ltd.
              - Manufacture and sale of heat-related products
        18. Qingdao Chaoli Car Parts Manufacturing Co., Ltd.
              - Manufacture and sale of heat-related products
        19. TIANJIN DENSO ELECTRONICS CO., LTD.
              - Manufacture and sales
                - electronic control products and parts
        20. TIANJIN DENSO ENGINE ELECTRICAL PRODUCTS CO., LTD.
              - Manufacture and sale
                - starters
                - alternators
                - PPS
        21. TIANJIN FAWER DENSO AIR-CONDITIONER CO., LTD.
              - Manufacture and sale
                - HVAC (excluding heat exchangers)
                - condensers
                - electric fans
                - ECMs (engine cooling modules)
        22. WUXI DENSO AUTOMOTIVE PRODUCTS CO., LTD.
              - Manufacture and sales
                - automotive engine control system products
                - air conditioning system products
        23. Yantai Chaoli Auto Electrical Parts Co., LTD
              - Manufacture and sale of heat-related products
        24. YANTAI SHOUGANG DENSO CO., LTD.
              - R&D, manufacturing and sales of automotive air conditioning system products
                - machinery air conditioners
                - agricultural machinery air conditioners
                - medium bus air conditioners
                - freezers and water tank radiators
    2.  South Korea
        1. DENSO KOREA CORPORATION
            - Manufacture and sale of automotive components Sale of non-automotive equipment and components
        2. KOREA WIPER BLADE CO., LTD.
            - Manufacture and sale of wiper arms, wiper blades, and wiper linkages
    3.  Taiwan
        1. DENSO TAIWAN CORP.
            - Manufacture and sales of 
              - air conditioners
              - radiators
              - bus air conditioners
              - alternators
              - non-automotive fields
    4.  Japan
        1. Anjo Plant
            - Manufacture
              - starters
              - alternators
              - Inverter
              - motor generator
              - electric power steering motor
        2. Nishio Plant
            - Manufacture
              - Car air conditioners
              - ratiators
              - electronic diesel/gasoline fuel injection components
        3. Takatana Plant
            - Manufacture
              - Instrument Cluster
              - Head-Up Display
              - Millimeter-Wave Radar Sensor
              - Vision Sensor
              - Power Module
              - various Sensors components
        4. Kosai Plant
            - Manufacture
              - compact motors for wiper systems
              - power windows
        5. Daian Plant
            - Manufacture
              - ignition components
              - Advanced safety products
              - valve train components
              - exhaust emission control components
        6. Kota Plant
            - Manufacture
              - integrated circuits
              - electronic control components
        7. Toyohashi Plant
            - Macufacture
              - air conditioners
              - Water pump for Fuel-cell vehicle
              - Servo Motor module
              - natural refrigerant (CO2) heat-pump hot water supply system
        8. Hirose Plant
            - Manufacture
              - Inverters
              - ECUs
              - Power semiconductors
        9. Agui Plant
            - Manufacture
              - machinery
              - tools
        10. Toyohashi East Plant
            - Manufacture
              - compact motors for blowers
              - cooling fans
        11. Zenmyo Plant
            - Manufacture
              - electronic diesel/gasoline fuel injection systems
        12. APINES INC.
            - Manufacture and sale
              - automotive small motors
              - their systems and related components.
        13. DENSO AIRCOOL CORPORATION
            - Design, development and manufacture
              - air-conditioners for buses
              - construction vehicles and agricultural vehicles
              - truck refrigerators
              - industrial air-conditioners
              - residential air-conditioners
              - heat exchangers.
        14. DENSO AIR SYSTEMS CORPORATION
            - Development, manufacture and sale
              - hoses
              - ducts
              - pipes for car air-conditioning systems
        15. DENSO DAISHIN CORPORATION
            - Manufacture
              - automotive fuel injection systems components
              - automotive air control system components. 
            - Development, design and manufacture of their production facilities.
        16. DENSO ELECTRONICS CORPORATION
            - Design and manufacture
              - automotive relays
              - electronic controllers.
        17. DENSO FA YAMAGATA CO., LTD.
            - Customized, automated production lines
        18. DENSO FUKUSHIMA CORPORATION
            - Manufacture and sale
              - air-conditioning systems
              - engine cooling modules and fuel injection/supply systems for gasoline engines.
        19. DENSO HOKKAIDO CORPORATION
            - Manufacture of automotive semiconductor products
        20. DENSO IWATE CORPORATION
            - Manufacture of automotive semiconductors and electronic device parts
        21. DENSO KATSUYAMA CO., LTD.
            - Manufacture and sale
              - components for hybrid vehicles
              - starters
              - ignition systems
              - intake air systems.
        22. DENSO KYUSHU CORPORATION
            - Manufacture
              - thermal systems products
              - diesel fuel injection systems components
              - intake air systems products
              - automotive wiper
              - washer systems products
        23. DENSO MIYAZAKI, INC.
            - Manufacture and sale
              - automotive compact motors and their related components
        24. DENSO PRESS TECH CO., LTD.
            - R&D and manufacture of stamping parts for automobiles
        25. DENSO SANKYO CO., LTD.
            - Development, manufacture and sale
              - heat exchanger for trucks and agricultural machineries
            - Manufacture and sale of air-conditioner for trucks
        26. DENSO TAIYO CO., LTD.
            - Assembly of automotive components
        27. DENSO TEN Limited
            - Development, design, manufacture and sale
              - audio-visual products
              - automotive electronics
        28. DENSO TEN TECHNOSEPTA Limited
            - Molding and processing of the resin parts for cars
        29. DENSO TRIM CORPORATION
            - Design and manufacture
              - motorcycle components
              - automobile components.
        30. DENSO WAVE INCORPORATED
            - Development, manufacture and sale
              -   automatic data capture equipment
              -   industrial robotsprogrammable controllers and IoT
              -   other apparatus and systems
        31. DENSO WIPER SYSTEMS, INC.
             -  Manufacture and sale
              -  automotive wiper blades
              -  wiper arms
              -  wiper links
        32. DENSO WISETECH CORPORATION
            - Manufacture and sale of automotive electric components.
        33. DENSO YAMAGATA CO., LTD.
            - Manufacture of flashers and buzzers. Design of electronic circuit board
        34. HAMADEN P.S CO.,LTD.
            - Attachment of vacuum switching valve hoses and door locks Manufacture of coils
        35. HAMANAKODENSO CO., LTD.
            - Manufacture and sale
              - horns
              - DCV (Duty Control Valve)
              - oil pressure control solenoid
              - NCS (Non-Contact Sensor)
              - VCT solenoid, magnet switch
        36. JECO CO., LTD.
            - Manufacture and sale
              - automobile clocks
              - instruments and their applied products.
        37. KYOSAN DENKI CO., LTD.
            - Manufacture and sale
              - fuel supply modules for automobiles.
            - Development and manufacture
              - fuel filters for trucks and agricultural machinery.
            - Manufacture
              - diesel common rail system parts and gasoline direct injection pump parts
        38. KYOSAN TECS CO., LTD.
            - Manufacture of pressed parts
            - manufacture and sale of residential door locks
        39. MAULTECH CORPORATION
            - Manufacture and sale of plastic products for car air conditioners and cooling systems
        40. NAGANO JECO CO., LTD.
            - Manufacture
              - automobile clocks
              - instruments
              - their applied products
        41. SHIMIZU INDUSTRY CO., LTD.
            - Manufacture and sale
              - plastic products and their dies for car air conditioners and cooling systems
- Southern Asia
    1.  India
        - DENSO HARYANA PVT. LTD.
            - Manufacture and sale of Automotive components : Powertrain , Electrification, Mobility Electronics and Thermal products
        - DENSO INDIA PVT. LTD.
            - Manufacture and sale of Automotive components : alternators, starters, 2W ECU, ACGS and ACG
        - DENSO KIRLOSKAR INDUSTRIES PVT. LTD.
            - Manufacture and sale of Automotive components : radiators, air-conditioners, and air cleaners. Sale of bus air-conditioners
        - DENSO TEN MINDA INDIA Private Limited
            - Designing, development, manufacturing, sale of CI (Car Infotainment) products and its accessories
        - DENSO THERMAL SYSTEMS PUNE PVT.LTD.
            - Manufacture and sale of Automotive components : air-conditioners, heaters, engine cooling module(ECM) & control panels
- South-Eastern Asia
    1.  Indonesia
        - PT. DENSO INDONESIA
          - Manufacture and sale of car air-conditioners, radiators, spark plugs, oxygen sensors, VCT
        - PT. DENSO MANUFACTURING INDONESIA
          - Manufacture of DC motors
        - PT. HAMADEN INDONESIA MANUFACTURING
          - Manufacture horns
    2.  Thailand
        - AIR SYSTEMS (THAILAND) CO., LTD.
          - Manufacture car air conditioner hoses and tubes
        - DENSO ELECTRONICS (THAILAND) Co., LTD.
          - Manufacture relays and flashers
        - DENSO (THAILAND) CO., LTD.
          - Manufacture of electrical components, air-conditioners, magnetos for motorcycles
        - DENSO TEN THAILAND Limited
          - Manufacture and sales of audio-visual products and automotive electronics
        - DENSO INNOVATIVE MANUFACTURING SOLUTION ASIA CO., LTD.
          - Manufacture and sale of mold & die, spare parts, jig & tools
        - SIAM DENSO MANUFACTURING CO., LTD.
          - Manufacture of fuel injection system products (fuel pumps and injectors)
        - SIAM KYOSAN DENSO CO., LTD.
          - Manufacture fuel pump modules and diesel fuel filters
    3.  Singapore
    4.  Vietnam
        - DENSO MANUFACTURING VIETNAM CO., LTD.
          - Manufacture and sale of engine-related products.
        - HAMADEN VIETNAM CO., LTD.
          - Manufacture automotive sensors and solenoid valves
    5.  Cambodia
        - DENSO (CAMBODIA) Co., Ltd.
          - Manufacture and sale of automotive & motorcycle parts
        - SANKYO RADIATOR (CAMBODIA) CO., LTD.
    6.  Malaysia
        - DENSO (MALAYSIA) SDN. BHD. (198001003055 (56839-A))
          - Manufacture and sale of car air-conditioners, electrical automotive components, and electronic products
        - DENSO WIPER SYSTEMS (MALAYSIA) SDN. BHD. (199501005004)
          - Manufacture and sale of automotive wiper systems
    7.  Philippines
        - DENSO PHILIPPINES CORPORATION
          - Manufacture and sale of instrument clusters, HVAC, radiators, sonars and smart keys
        - Jeco Autoparts Philippines, Inc.
          - Automobile clocks
        - DENSO TEN PHILIPPINES CORPORATION
          - Manufacture and sales of audio-visual products and automotive electronics
- Western Asia
    1.  UAE
- Oceania
    1.  Australia
- North Africa
    1.  Morocco
        - DENSO THERMAL SYSTEMS MOROCCO S.A.R.L.
          - Manufacture of air-conditioners & ECM-related products
- Southern Africa
    1.  South Africa
- North America
    1.  USA
        1. DENSO AIR SYSTEMS KENTUCKY,INC.
            - Manufacture of hose and tube piping for underfloor
        2. DENSO MANUFACTURING ARKANSAS, INC.
            - Manufactures HVAC and ECM units
        3. DENSO MANUFACTURING ATHENS TENNESSEE, INC.
            - Manufacture of exhaust gas sensors, injector, pumps, coils, spark plugs, and monolithic carriers
        4. DENSO MANUFACTURING MICHIGAN, INC.
            - Manufactures evaporators, condensers, cooling units, radiators, heaters, HVACs and manages sales of air-conditioner parts
        5. DENSO MANUFACTURING NORTH CAROLINA, INC.
            - Manufactures smart motors for various applications, pinch sensors, wiper systems, and washer systems
        6. DENSO MANUFACTURING TENNESSEE, INC.
            - Manufactures electrification and safety components, instrument clusters, and automotive electronic products
        7. DENSO TEN TECHNOSEPTA USA, Limited
            - Molding and processing vehicle resin parts
        8. YSTEX PRODUCTS ARKANSAS COMPANY
            - Manufactures plastic products for automotive air conditioners
        9. SYSTEX PRODUCTS CORPORATION
            - Manufactures plastic products for automotive air conditioners
    2.  Mexico
        - DENSO AIR SYSTEMS DE MEXICO S.A.DE C.V.
          - Manufactures spot-coolers and hoses for car air conditioners
        - DENSO MEXICO S.A. DE C.V.
          - Manufacture of mechatronics components, cockpit components, electric components, air-conditioners
        - DENSO TEN DE MÉXICO, S.A. DE C.V.
          - Manufactures and manages sales of audio-visual products and automotive electronics
        - HAMADEN MEXICO S.A. DE C.V.
          - Manufactures solenoids and valves for engine management and pneumatic control
    3.  Canada
        - DENSO MANUFACTURING CANADA, INC.
          - Manufactures HVAC and ECM (Condensers/Radiators)
- South America
    1.  Brazil
        - DENSO DO BRASIL LTDA.
          - Manufacture and sales of air-conditioners, heaters, compressors, radiators, starters, wipers and instrument clusters
        - DENSO INDUSTRIAL DA AMAZONIA LTDA.
          - Manufacture and sale of Generators, CDI and ECU for motorcycles, and ECU and Meter for cars
        - DENSO MAQUINAS ROTANTES do BRASIL LTDA.
          - Manufacture and sale of alternators and wipers
        - DENSO SISTEMAS TERMICOS do BRASIL LTDA.
          - Manufcture and sale of A/C, Heater, Front end, Radiator, Cooling Module
    2.  Argentina
        - DENSO MANUFACTURING ARGENTINA S.A.
          - Manufacture and sale of air-conditioners, radiators and cockpits
- Eastern Europe
    1.  Hungary
        - DENSO MANUFACTURING HUNGARY LTD.
          - Manufacture and sale of common rail systems and other engine related products
    2.  Czech
        - DENSO CZECH s.r.o.
          - Assembly of wiper motors and A/B and logistics services for DNEU
        - DENSO MANUFACTURING CZECH s.r.o.
          - Manufacture and sale of HVAC, evaporators, condenser, heater cores, radiators and hoses
        - LIPLASTEC s.r.o.
          - Manufacture plastic products for car air conditioners
    3.  Poland
        - DENSO POLAND Sp. z o.o.
          - Manufacture of instrument clusters
        - DENSO THERMAL SYSTEMS POLSKA Sp. z o.o.
          - Manufacture of air-conditioners, heaters, cockpit modules, front-end modules and cooling modules
    4.  Turkey
        - DENSO OTOMOTIV PARCALARI SANAYI A.S.
          - Manufacture and sale of air-conditioners and ECM, and sale of starters, alternators, wipers
    5.  Russia
- Northern Europe
    1.  England
        - DENSO MANUFACTURING UK LTD.
          - Manufacture of air-conditioners, heaters and radiators and air cleaners
        - DENSO MARSTON LTD.
          - Manufacture and sale of radiators, oil coolers, intercoolers, fuel coolers
    2.  Sweden
- Southern Europe
    1.  Italy
        - DENSO MANUFACTURING ITALIA S.p.A.
          - Manufacture and sale of starters, alternators, and small motors
        - DENSO THERMAL SYSTEMS S.p.A.
          - Manufacture and sale of air-conditioners, heaters, radiators and front-end modules
    2.  Spain
        - DENSO BARCELONA S.A.U.
          - Manufacture of automotive electronic products and engine control components
        - DENSO SISTEMAS TERMICOS ESPANA S.A.
          - Manufacture and sale of car air-conditioners, heaters, and engine cooling modules
        - DENSO TEN ESPAÑA, S.A.
          - Manufacture and sales of car audio products, automotive electronics and IT-related products
    3.  Portugal
        - João de Deus & Filhos, S.A.
          - Manufacture and sale of radiator and intercooler and molds and tooling
- Western Europe
    1.  Netherlands
    2.  Germany
    3.  Belgium
    4.  France
=> 36

# Installing

https://www.vmware.com/products/workstation-player.html

https://releases.ubuntu.com/focal/

# 1. Set locale

locale

sudo apt update && sudo apt install locales

sudo locale-gen en_US en_US.UTF-8

sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8

export LANG=en_US.UTF-8

locale

# 2. Set sources

apt-cache policy | grep universe

sudo apt install software-properties-common

sudo add-apt-repository universe

sudo apt update && sudo apt install curl gnupg2 lsb-release

sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg

echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null

# 3. Install ROS2 packages 

sudo apt update

sudo apt upgrade

sudo apt install ros-foxy-desktop python3-rosdep2

rosdep update

# 4. Environment setup 

source /opt/ros/foxy/setup.bash

rosversion -d


# Secure Shell 

ping <iron-X’s ip-address>

ssh pi@<iron-X’s ip-address>

password: ironxtesr

# Download link

https://www.nomachine.com/download/linux&id=1

# Install

cd ~/Downloads

ls

sudo dpkg -i nomachine_7.10.1_1_amd64.deb

# setup ROS_DOMAIN_ID

# PC site

sudo nano ~/.bashrc

export ROS_DOMAIN_ID=99

source .bashrc

# iron-X site

ssh pi@<iron-X’s ip-address>

sudo nano ~/.bashrc

export ROS_DOMAIN_ID=99

source .bashrc

# add /opt/ros/foxy/setup.bash to bashrc 

echo "source /opt/ros/foxy/setup.bash" >> ~/.bashrc

# Secure shell

ssh pi@<iron-X’s ip-address>

password: ironxtesr

# iron-X's driver

# Remote Terminal

ros2 run ironx_bringup ironx_driver

# PC/Laptop Terminal

ros2 topic list

ros2 topic echo /odom

ros2 topic echo /imu

ros2 topic echo /ironx_voltage

# Keyboard&Joy
# Remote Terminal

ros2 run ironx_bringup ironx_driver

# PC/Laptop Terminal

ros2 run teleop_twist_keyboard teleop_twist_keyboard

# iron-X's bringup
# Remote Terminal

ros2 launch ironx_bringup ironx_start.launch.py

#For active the camera

ros2 launch ironx_bringup ironx_start.launch.py use_cam:=True

# PC/Laptop Terminal

ros2 topic list

rviz2

# Download source

https://drive.google.com/file/d/1xes6B_hU-zJPYAYlC6yXcZ8h1SdLFuV7/view

# create workspace and src 
(In case, you didn't have workspace)

mkdir -p ros2_ws/src

# build workspace

cd ros2_ws/
rosdep install -i --from-path src --rosdistro foxy -y

# install colcon

sudo apt install python3-colcon-common-extensions

colcon build --symlink-install
. install/setup.bash

echo "source ~/ros2_ws/install/setup.bash" >> ~/.bashrc

# Cartographer SLAM
# Remote terminal

ros2 launch ironx_bringup ironx_start.launch.py

# PC/Laptop terminal

ros2 launch ironx_navigation cartographer.launch.py

#use Keyboard

ros2 run teleop_twist_keyboard teleop_twist_keyboard

# Save a map from SLAM
# PC/Laptop terminal

ros2 run nav2_map_server map_saver_cli -f ~/<Map_path/map's_name>

# Navigation
# Remote terminal

ros2 launch ironx_bringup ironx_start.launch.py

# PC/Laptop terminal

ros2 launch ironx_navigation navigation.launch.py map:=~/<Map_path/map's_name>

#For activate the omnidirectional

ros2 launch ironx_navigation navigation.launch.py use_omni:=true map:=~/<Map_path/map's_name>

# Camera Streaming
# On Remote Desktop(NoMachine)

Username: pi
Password: ironxtesr

ros2 launch opencv_2d_camera opencv_vdo_streaming.launch.py

# On PC/Laptop terminal

rviz2

# ironx's driver

# On Remote Desktop or Remote Terminal

ros2 run ironx_bringup ironx_driver

# On Remote Desktop

# ARUCO MARKER Tracking

ros2 launch opencv_2d_camera opencv_aruco.launch.py

# Face Tracking

ros2 launch opencv_2d_camera opencv_face_detection.launch.py

# Color Tracking

ros2 launch opencv_2d_camera opencv_color_detection.launch.py

# Lowerbody Tracking

ros2 launch opencv_2d_camera opencv_lowerbody_detection.launch.py

https://www.sciencedirect.com/science/article/pii/S1569190X21001271

https://www.researchgate.net/publication/346641010_A_Review_of_Recent_Advances_in_Automated_Guided_Vehicle_Technologies_Integration_Challenges_and_Research_Areas_for_5G-Based_Smart_Manufacturing_Applications

https://6river.com/what-are-automated-guided-vehicles/

https://www.anylogic.com/blog/how-to-build-a-simple-agv-charging-model-for-warehousing-and-manufacturing/

https://wewo-techmotion.com/solutions/automatic-guided-vehicle/agv-software/agv-fleet-management-software

https://ubuntu.com/blog/guide-to-autonomous-mobile-robots

#

- What is AMR?
  - Autonomous mobile robots (AMRs) are robotic vehicles that operate without the need for human control or intervention
  - หุ่นยนต์เคลื่อนที่อัตโนมัติ (AMR) เป็นยานพาหนะหุ่นยนต์ที่ดำเนินการโดยไม่จำเป็นต้องมีการควบคุมหรือแก้ไขจากมนุษย์
  - 
  - And autonomous mobile robot is a specialized robot that is able to dynamically navigate and avoid obstacles in complex industrial work environments and do not require the restriction of humans from operating in areas
  - หุ่นยนต์เคลื่อนที่อัตโนมัติเป็นหุ่นยนต์เชิงพาณิชย์ที่เฉพาะเจาะจง สามารถเดินทางและหลีกเลี่ยงอุปสรรคในสภาพแวดล้อมการทำงานอุตสาหกรรมที่ซับซ้อนได้อย่างไร้ขีดจำกัดจากมนุษย์ในการดำเนินงานในพื้นที่ดังกล่าว
  - 
  - An autonomous mobile robot is a type of robot that can understand and move through its environment independently
  - หุ่นยนต์เคลื่อนที่อัตโนมัติเป็นชนิดหนึ่งของหุ่นยนต์ที่สามารถเข้าใจและเคลื่อนที่ผ่านสิ่งแวดล้อมได้อิสระโดยไม่ต้องมีมนุษย์ควบคุมโดยตรง
  - 
  - An autonomous mobile robot, or AMR, is a robot capable of navigating its surrounding environment without human oversight
  - หุ่นยนต์เคลื่อนที่อัตโนมัติหรือ AMR เป็นหุ่นยนต์ที่สามารถเดินทางในสิ่งแวดล้อมรอบตัวได้โดยไม่ต้องมีการควบคุมจากมนุษย์
  - 
  - An autonomous mobile robot (AMR) is any robot that can understand and move through its environment without being overseen directly by an operator
  - หุ่นยนต์เคลื่อนที่อัตโนมัติหรือ AMR คือหุ่นยนต์ที่สามารถเข้าใจและเคลื่อนที่ผ่านสิ่งแวดล้อมได้อิสระโดยไม่ต้องมีผู้ควบคุมควบคุมโดยตรง
  - 
  - An autonomous mobile robot (AMR) is a robot that performs behaviors or tasks with a high degree of autonomy
  - หุ่นยนต์เคลื่อนที่อัตโนมัติหรือ AMR เป็นหุ่นยนต์ที่มีการทำพฤติกรรมหรืองานที่มีระดับความเป็นอิสระสูง
  - 
  - Autonomous mobile robot, also known as auto robot or auto boot is used to pick, transport, and sort items within manufacturing and distribution facilities without any manual intervention. This is a form of automatic guided vehicle (AGV) that can be implemented without any supporting infrastructure like wires, magnets implanted on the floor or precisely located laser targets
  - หุ่นยนต์เคลื่อนที่อัตโนมัติหรือ Auto Robot หรือ Auto Boot ใช้ในการเลือก ขนย้าย และเรียงลำดับสินค้าภายในโรงงานผลิตและศูนย์กระจายสินค้าโดยไม่ต้องมีการแทรกแซงด้วยมือ นี่เป็นรูปแบบของยานพาหนะชนิด Automatic Guided Vehicle (AGV) ที่สามารถนำมาใช้ได้โดยไม่ต้องมีโครงสร้างสนับสนุนเพิ่มเติมเช่น ลวดไฟ แม่เหล็กฝังตัวในพื้นหรือเป้าหมายเลเซอร์ที่ตั้งตำแหน่งได้อย่างแม่นยำ
  - 
  - Autonomous mobile robots serve a similar purpose to AGVs, but are fully autonomous, meaning they require no custom infrastructure (like beacons) or specialized training to operate. AMRs are typically easy to deploy, and can be re-programmed on the fly to follow new routes as needed. If AGVs are like trains running on fixed tracks, then consider AMRs like cars—able to roam and change direction at any time, while avoiding people and obstacles.
  - หุ่นยนต์เคลื่อนที่อัตโนมัติบริการทำงานเช่นเดียวกับ AGV แต่เป็นอิสระแบบเต็มรูปแบบซึ่งหมายความว่าไม่ต้องการโครงสร้างที่กำหนดเอง (เช่นจุดอ้างอิง) หรือการฝึกฝนเฉพาะทางเพื่อดำเนินการ หุ่นยนต์เคลื่อนที่อัตโนมัติทั่วไปจะง่ายต่อการใช้งานและสามารถเข้ารหัสใหม่ได้เพื่อดำเนินเส้นทางใหม่ตามต้องการ ถ้า AGV เหมือนกับรถไฟที่วิ่งบนรางคงที่ ก็คือ AMR เหมือนกับรถยนต์ สามารถเดินทางและเปลี่ยนทิศทางได้ตลอดเวลา โดยหลีกเลี่ยงคนและอุปสรรค
  - 
  - The newest breed of AMRs leverage artificial intelligence (AI), 3D cameras, and LiDAR sensors so they can operate safely not only in warehouses, but also within high-traffic locations such as retail and grocery stores, malls, airports, schools, healthcare facilities, and more. This unlocks new opportunities for public-facing businesses and their employees to use robotic automation to handle dull, dirty, and repetitive tasks, such as cleaning floors, hauling carts, or managing shelf inventory.
  - ชนิดล่าสุดของ AMRs ใช้เทคโนโลยีปัญญาประดิษฐ์ (AI) กล้อง 3 มิติและเซ็นเซอร์ LiDAR เพื่อทำให้สามารถทำงานอย่างปลอดภัยไม่เพียงแค่ในโกดังเก็บของ แต่ยังสามารถทำงานได้ในสถานที่ที่มีความหนาแน่นของคนเช่นห้างสรรพสินค้า ร้านสะดวกซื้อ ศูนย์การค้า สนามบิน โรงเรียน สถานพยาบาล และอื่น ๆ นอกจากนี้ยังเปิดโอกาสใหม่สำหรับธุรกิจที่เผชิญกับปริมาณงานที่มีความน่าเบื่อระหว่างการทำความสะอาดพื้น ขนส่งรถเข็นหรือการจัดการสินค้าในชั้นวางสินค้า เป็นต้น
  - 
  - Newer AMRs, like the ones that Brain Corp develops together with its manufacturing partners, are also characterized by intuitive user interfaces that make it easy for non-technical employees to train and use the robots, as well as near real-time operational data that can be used to verify and optimize performance.
  - AMR รุ่นใหม่ล่าสุด เช่นเดียวกับที่ Brain Corp พัฒนาขึ้นร่วมกับพันธมิตรในการผลิต มีลักษณะเชิงบริหารง่ายที่ทำให้พนักงานที่ไม่มีความชำนาญด้านเทคนิคสามารถฝึกและใช้หุ่นยนต์ได้ง่าย และยังมีข้อมูลการทำงานแบบเรียลไทม์ที่ใช้สำหรับตรวจสอบและปรับปรุงประสิทธิภาพได้ใกล้เคียงกับเวลาจริง
  - 
  - Based on the concept of smart cabinets and smart autonomous mobile robots, it has a sound AMR smart transportation system and a variety of sensing devices to provide the premium service. It has a background management system and remote control, ensuring all goods are saved and retrieved with safety. You can set when and where to deliver the goods, a new smart and innovative logistics service that collects the goods within 24 hours. In addition, a variety of identification devices equip Barcode, QRcode and RFID feature for third-party management integration to provide the most user-friendly service. The AMR-AI-Logistics Robot has the ability of cross-floor distribution, which can autonomously get the access and elevators control to reach designated floors.
  - โดยใช้แนวคิดของตู้เก็บของอัจฉริยะและหุ่นยนต์เคลื่อนที่อัตโนมัติอัจฉริยะ ระบบขนส่งอัตโนมัติอัจฉริยะด้วยเสียงและมีอุปกรณ์ตรวจจับหลายชนิดที่ให้บริการคุณภาพเยี่ยม มีระบบการจัดการพื้นหลังและการควบคุมระยะไกล เพื่อให้สินค้าทั้งหมดถูกเก็บรักษาและเรียกคืนอย่างปลอดภัย คุณสามารถตั้งค่าเวลาและสถานที่ในการส่งสินค้าได้ บริการโลจิสติกส์อัจฉริยะและนวัตกรรมใหม่ที่เก็บสินค้าภายใน 24 ชั่วโมง นอกจากนี้ยังมีอุปกรณ์ระบบระบุตัวต่างๆ เช่น Barcode, QRcode และ RFID สำหรับการบริหารจัดการโดยบุคคลภายนอก เพื่อให้บริการที่ใช้งานง่ายที่สุด หุ่นยนต์โลจิสติกส์ AMR-AI มีความสามารถในการกระจายสินค้าได้ทั้งตึก โดยสามารถเข้าถึงและควบคุมลิฟท์ได้อย่างอัตโนมัติเพื่อเข้าถึงชั้นที่กำหนดได้
- Kind of AMR?
- Structure of AMR?

# ROS2
# Lecture 1 : ROS2 Fundamentals
- Topic >> Getting Know ROS
  - ROS is an actual software framework for developing systems
    - ROS เป็นกรอบโครงสร้าง software ที่ใช้ในการพัฒนาระบบ
  - A cluster of computer
    - เป็นกลุ่มของคอมพิวเตอร์
  - Used with a robotics hardware that have operating system
    - ถูกใช้กับ hardware robotics ที่มีระบบปฏิบัติการ
  - ROS's abilities
    - ความสามารถของ ROS
    - Tools, Standards, Conventions, Resource Sharing Platform
      - เครื่องมือ, ความมาตรฐาน, กติกา, แพล็ตฟอร์มการแบ่งปันทรัพยากร
  - Programming Languages for ROS
    - ภาษาโปรแกรมสำหรับ ROS
    - The Best : Python, C++
      - ดีที่สุด : Python, C++
    - Other : MATLAB, Julia, Lua, Java, Rust, Lisp
      - อื่นๆ : MATLAB, Julia, Lua, Java, Rust, Lisp
  - Common type of information used in robotics (ROS message type)
    - ชนิดของข้อมูลทั่วไปที่ถูกใช้ใน robotics (ชนิดข้อมความของ ROS)
    - Accel, Inertia, Point, Point32, Pose, Pose2D, Quaternion, Transform, Twist, Vector3, Wrench, BatteryState, CameraInfo, CompressedImage, Image, Imu, JointState, Joy, LaserScan, PointCloud, Temperature
  - ROS community package
    - package ของ ROS
    - global_planner, rviz, map_server, gazebo, camera_calibration, aruco_detect, ros_control
  - Physical System/Simulation
    - ระบบทางกายภาพ/การจำลอง
    - Physical System uses less power or resource : Because A computer runs only robot
      - ระบบทางกายภาพใช้พลังงานหรือทรัพยากรน้อย เพราะคอมพิวเตอร์จะรันการทำงานของหุ่นยนต์เท่านั้น
    - Simulation uses more power or resource : Because A computer uses a lot of resource to build simulation in computer and robot
      - การจำลองใช้พลังงานหรือทรัพยากรเยอะ เพราะคอมพิวเตอร์จะใช้ทรัพยาเยอะในการจำลองหุ่นยนต์ในคอมพิวเตอร์และการรันหุ่นยนต์

- Topic >> Introduction to ROS2
  - Issues from using ROS
    - ปัญหาจากการใช้ ROS
    - ROS was not designed to support a system of multiple robots due to its used of a single master node.
      - ROS ไม่ได้ถูกออกแบบมาเพื่อสนับสนุนหุ่นยนต์หลายตัว เพราะมันใช้โหลดหลักแค่ตัวเดียว
    - ROS was designed so that the resources should be local (contains within the computer) for optimal performance.
      - ROS ถูกออกแบบให้มีทรัพยากรอยู่ในคอมพิวเตอร์เพื่อให้มีประสิทธิภาพสูงสุด
    - The paradigm of communication was not design to support real time operation.
      - รูปแบบการสื่อสารไม่ได้ถูกออกแบบเพื่อรองรับการทำงานแบบ real-time
    - ROS was essentially a centralized system, which is not designed to support fleet management.
      - ROS เป็นระบบที่มีการควบคุมแบบกลาง ซึ่งไม่ได้ถูกออกแบบมาเพื่อรองรับการจัดการกลุ่มหุ่นยนต์
  - Some of many benefits of ROS2
    - ประโยชน์บางส่วนของ ROS
    - Utilize Data Distribution System instead of TCPROS
      - ใช้ระบบกระจายข้อมูลแทน TCPROS
    - Support multiple operating system such as linux, Windows, and OSX
      - สนับสนุนหลายระบบปฏิบัติการ
    - Launch files can be writen using Python script
      - ไฟล์ launch เขียนได้โดยใช้ Python script
  - ROS2 Distributions
    - การกระจายของ ROS2
    - A ROS distribution is a versioned set of ROS packages
      - การกระจายของ ROS เป็นชุด version ของ ROS packages

- Topic >> Navigating Linux Terminal
  - File System & Path
    - ไฟล์ระบบและ path
    - Explains about information in file system and path
      - อธิบายเกี่ยวกับข้อมูลไฟล์ของระบบและ path
    - Example : Directory, File, Data file, Executablbe file, Path
      - โฟลเดอร์, ไฟล์, ไฟล์ข้อมูล, ไฟล์ที่สามารถรันได้, path
  - Terminal & Command
    - Using command in terminal to manages file
      - การใช้คำสั่งใน terminal ในการจัดการไฟล์
  - Bash Programming
    - Finding a file in system. If the system can't find it will generate a new file in system
      - การหาไฟล์ในระบบ ถ้าระบบค้นหาไม่เจอ ก็จะสร้างไฟล์ใหม่ขึ้นมา

- Topic >> Using ROS2 in terminal
  - การใช้ ROS2 ใน terminal
  - The concept of Nodes and Topics
    - Node : process
    - Topic : communication channel
    - Publisher : publish a message to a topic
      - publisher เป็นตัวส่งข้อความไปที่ topic
    - Subcriber : subscribe a message from a topic
      - subcriber เป็นตัวรับข้อความจาก topic
    - Each node shouldn't have both a publisher and a subscription
      - แต่ละโหนดไม่ควรเป็นทั้ง publisher และ subscriber ในตัวเดียวกัน
  - The concept of message
    - message is an operation command that subscriber brings it to operate
    - ข้อความเป็นคำสั่งการดำเนินการที่ subscriber นำไปใช้ในการดำเนินการ
  - The concept of service
    -  1-1 communication
      - การสื่อสารแบบ 1-1
    -  Suitable for more private communication that happens once in a while
      - เหมาะกับการสื่อสารแบบส่วนตัวที่เกิดขึ้นบางครั้ง
    -  provides service to a service client from other nodes.
      - ให้บริการกับ client จากโหนดอื่นๆ
  - The concept of ROS2 Parameter
    - Parameter is a constant that is associated with that particular node
      - parameter ค่าคงที่ที่เกี่ยวข้องกับ node นั้นๆ
    - It can be modified and accessed by terminal interface
      - สามารถแก้ไขและเข้าถึงผ่าน interface ทางคำสั่ง terminal ได้
  - The concept of action
    - 1-1 communication
      - การสื่อสารแบบ 1-1
    - Suitable for task that requires time to complete such as planning, optimizing, navigating, etc.
       -  เหมาะสำหรับงานที่ต้องใช้เวลาในการดำเนินการ เช่น การวางแผน การปรับปรุงประสิทธิภาพ การนำทาง เป็นต้น
    - A node can have an action server that execute an "action", then return the result to the client.
      - โหนดสามารถมี action server ที่ดำเนินการ "action" แล้วส่งผลลัพธ์กลับไปยัง client ได้
  - Using existing system with ROS2
    - การใช้ระบบที่มีอยู่แล้วกับ ROS2
    - Given existing ROS2 packages, we can now know how to execute some of their functionalities via terminal command.
      - จากแพ็กเกจ ROS2 ที่มีอยู่แล้ว เราสามารถรู้วิธีการดำเนินการบางส่วนของฟังก์ชันผ่านคำสั่งทาง terminal

- Topic >> ROS2 Package Customization
  - The concept of Package
    - Package is a collection of organized files in a form of directory, which will used to "synthesize" nodes, launch system, etc. (usually for a specific task)
      - แพ็กเกจคือการรวมไฟล์ที่มีการจัดเรียงแบบเป็นระบบเข้าด้วยกันในรูปแบบของไดเรกทอรี ซึ่งจะถูกนำมาใช้ในการ "สังเคราะห์" โหนด (nodes) ระบบเปิด (launch system) ฯลฯ (โดยมักจะใช้สำหรับงานที่เฉพาะเจาะจง)
    - An anology of a package would be a folder where we can keep all blue prints of a house but not the house itself.
      - การอธิบายแพ็กเกจโดยใช้สมมติฐานเป็นการเปรียบเทียบกับโฟลเดอร์ที่เราสามารถเก็บแบบแผนทั้งหมดหรือโครงสร้างที่ใช้สร้างระบบหรือแอปพลิเคชันไว้ในนั้น แต่ไม่ใช่ตัวแอปพลิเคชันหรือระบบ
  -  Source folder (src)
    - "src" directory is where we put all custom packages together.
      - โฟลเดอร์ "src" เป็นที่เก็บแพ็กเกจที่เราสร้างขึ้นเองทั้งหมดใน ROS โดยเฉพาะ โดยทั่วไปแล้วเราจะสร้างแพ็กเกจขึ้นมาเองเมื่อต้องการเพิ่มฟังก์ชั่นเสริมใน ROS ที่ไม่มีให้ในแพ็กเกจพื้นฐาน หรือเพื่อปรับแต่งแพ็กเกจที่มีอยู่เพื่อให้ตอบสนองกับความต้องการของโปรแกรมที่เราพัฒนา ดังนั้น "src" เป็นโฟลเดอร์ที่สำคัญในการพัฒนา ROS และใช้เก็บแพ็กเกจที่เราสร้างขึ้นเองทั้งหมดใน ROS
    - A package can be put inside another folder, which can be referred as a meta-package.
      - แพ็กเกจสามารถเก็บไว้ภายในโฟลเดอร์อื่นได้ โดยที่โฟลเดอร์นั้นจะเรียกว่า "meta-package" ซึ่งเป็นการจัดเก็บแพ็กเกจที่เกี่ยวข้องกันด้วยกันไว้ในโฟลเดอร์เดียวกันเพื่อความสะดวกในการจัดการ และบางครั้งเราอาจใช้แพ็กเกจ meta-package เพื่อทำการติดตั้งแพ็กเกจต่าง ๆ ที่เกี่ยวข้องกันในครั้งเดียวกัน อย่างไรก็ตามใน ROS 2 นั้นแนะนำให้ใช้งานโครงสร้างของ multi-package แทน meta-package
    - The concept of Workspace
      - workspace is where we put every custom packages for a project.
        - Workspace คือพื้นที่ที่เราใช้สำหรับเก็บแพ็กเกจทั้งหมดที่เกี่ยวข้องกับโปรเจกต์ใน ROS 2 โดย Workspace ประกอบด้วยโฟลเดอร์หลักสองโฟลเดอร์ คือ src และ install โฟลเดอร์ src เป็นที่เก็บโค้ดและแพ็กเกจที่เราพัฒนาขึ้นมาเอง และโฟลเดอร์ install เป็นที่เก็บแพ็กเกจที่ติดตั้งเพื่อให้โปรแกรม ROS 2 ทำงานได้ โดย Workspace มักถูกแบ่งออกเป็น Workspace เดี่ยวหรือ Multi-Workspace โดย Multi-Workspace จะใช้สำหรับการพัฒนาโปรเจกต์ที่มีหลาย Workspace ที่ต้องทำงานร่วมกัน
    - Build System
      - "colcon build" command will build every packages in the source directory and generate 3 additional directories. When modify "src", always re-build these 3 directories. (with an exception of using symlink install)
        - คำสั่ง "colcon build" จะทำการสร้างแพ็กเกจทั้งหมดที่อยู่ในโฟลเดอร์ src และสร้างโฟลเดอร์เพิ่มเติมอีก 3 โฟลเดอร์คือ build, install, และ log โดยโฟลเดอร์ build เป็นที่เก็บไฟล์ที่ถูกคอมไพล์ โฟลเดอร์ install เป็นที่เก็บแพ็กเกจที่ติดตั้งและใช้ในการรันโปรแกรม และโฟลเดอร์ log เป็นที่เก็บไฟล์ log ที่เกี่ยวข้องกับการทำงานของแต่ละแพ็กเกจ
เมื่อเราทำการแก้ไขโค้ดในโฟลเดอร์ src ให้ใช้คำสั่ง "colcon build" เพื่อสร้างแพ็กเกจใหม่ทั้งหมด พร้อมกับการอัปเดตโฟลเดอร์ build และ install เพื่อให้โปรแกรม ROS 2 ทำงานได้อย่างถูกต้อง โดยมีข้อยกเว้นว่าถ้าเราใช้ symlink install จะไม่ต้อง build install ใหม่ทุกครั้งที่แก้ไขโค้ดในโฟลเดอร์ src แต่ต้องทำการลิงค์โฟลเดอร์ install กับโฟลเดอร์ build ก่อนเพื่อให้โปรแกรม ROS 2 ใช้ไฟล์แพ็กเกจล่าสุดที่ถูกอัปเดต
      - "Install" directory is the location of codes that will be used by the ROS2 system. Therefore, only modifying "src" will not change the behavior of your system in run time.
        - โฟลเดอร์ "install" เป็นตำแหน่งที่จะเก็บรหัสที่จะถูกใช้โดยระบบ ROS2 ดังนั้นการแก้ไขเฉพาะ "src" จะไม่สามารถเปลี่ยนแปลงพฤติกรรมของระบบในเวลาเรียลไทม์ได้ จะต้องสร้างแพ็คเกจใหม่และอัปเดตโฟลเดอร์ "install" โดยใช้คำสั่ง "colcon build" เพื่อนำการเปลี่ยนแปลงมาใช้ในการทำงานของระบบในเวลาเรียลไทม์
      - You must not create workspace inside another workspace
        - คุณต้องไม่สร้าง workspace ภายใน workspace อื่น ๆ
    - Creating a new workspace
      - การสร้าง workspace ใหม่
      - Create and build a new workspace
        - สร้างและ build workspace อันใหม่
        - >> mkdir –p ~/[xxx]_ws/src, >> cd ~/[xxx]_ws, >> colcon build
      - Adding workspace to .bashrc
        - source ~/[xxx]_ws/install/local_setup.bash
      - Creating a ROS Package
        - for python
          - >> cd ~/[xxx]_ws/src, >> ros2 pkg create --build-type ament_python [package_name]
        - for C++
          - >> cd ~/[xxx]_ws/src, >> ros2 pkg create --build-type ament_cmake [package_name]
        - The package that we create must be in the src directory of our workspace.
        - แพ็กเกจที่เราสร้างต้องอยู่ในโฟลเดอร์ src ของ workspace ของเรา
      - Creating my_first_pkg
        - >> cd ~/[xxx]_ws/src, >> ros2 pkg create --build-type ament_python my_first_pkg, >> cd .., >> colcon build --packages-select my_first_pkg, >> cd src/my_first_pkg, >> code package.xml, >> cd my_first_pkg, >> code my_first_script.py
      - Structure of CMakeLists.txt for building a package
      
- Topic >> ROS2 Node Programming with RCLPY
  - การเขียนโปรแกรม Node ใน ROS2 ด้วย RCLPY
  - Node class in ROS Client Library for Python (RCLPY)
    - คลาส Node ในไลบรารี ROS Client สำหรับ Python (RCLPY)
  - General procedure on "running" a node using RCLPY
    - ขั้นตอนทั่วไปในการ "รัน" node โดยใช้ RCLPY
    - เริ่มต้น rclpy โดยใช้ 'rclpy.init'
    - สร้างออบเจ็กต์ "Node"
    - เริ่มการทำงานของ node โดยใช้ rclpy.spin หรือ spin อยู่ใน while-loop
    - หากกระบวนการสิ้นสุดลูป ให้ยกเลิกการสร้างออบเจ็กต์ของ Node
    - ปิดการใช้งาน rclpy โดยใช้ rclpy.shutdown"
  - Inheriting a Node classfrom RCLPY
    - การสืบทอดคลาส Node จาก RCLPY
- Topic >> Timer, Publisher, & Subscription
  - Attaching a timerto the node
    - การเชื่อมต่อตัวตั้งเวลากับโหนด
  - Attaching a publisher and publishing a message in a timer
    - เพื่อที่จะทำการ attach publisher และ publish message โดยมีการใช้ timer
  - Attaching a subscription and its callback
    - การ attach subscription และ callback
  - Finite State Machine
    - Finite State Machine (FSM) หรือเครื่องกำหนดสถานะจำกัดคือแบบจำลองทางคณิตศาสตร์ที่ประกอบด้วยสถานะ (state) ที่มีการเปลี่ยนแปลงตามกฎหรือเหตุการณ์ที่เกิดขึ้น และมีการระบุสถานะเริ่มต้น (initial state) และสถานะปลาย (final state) เพื่อบอกว่าเครื่องกำหนดสถานะจำกัดจะจบการทำงานเมื่อเข้าสถานะปลาย
FSM มักใช้ในการออกแบบการทำงานของระบบและโปรแกรมที่มีลำดับขั้นตอนและมีการตรวจสอบเงื่อนไขในแต่ละขั้นตอน โดยสามารถแบ่งสถานะและเหตุการณ์เป็นกลุ่ม เช่น สถานะของเครื่อง ATM อาจเป็น "รอให้ผู้ใช้ป้อนรหัส PIN", "รอให้ผู้ใช้เลือกบริการ", "กำลังดำเนินการเบิกเงิน" เป็นต้น และเหตุการณ์อาจเป็น "ผู้ใช้ป้อนรหัส PIN ผิด", "ผู้ใช้เลือกบริการเบิกเงิน", "การดำเนินการเบิกเงินสำเร็จ" เป็นต้น

- Topic >> Object-Oriented Programming
  - Object-Oriented Programming (OOP) หรือการเขียนโปรแกรมเชิงวัตถุ เป็นแนวคิดในการเขียนโปรแกรมที่มุ่งเน้นการจัดการกับ Object หรืออ็อบเจ็กต์ซึ่งเป็นสิ่งมีชีวิตเสมือนในโลกจริง โดย Object จะมีคุณสมบัติ (property) และพฤติกรรม (behavior) เช่นเดียวกับสิ่งที่เราเห็นรอบตัว เช่น แมวจะมีคุณสมบัติเช่น สีของขน น้ำหนัก อายุ และพฤติกรรมเช่น การเดิน การร้องเพลง เป็นต้น
ใน OOP จะมีคอนเซปต์เบื้องต้นคือคลาส (Class) ซึ่งจะถูกนิยามโดยคุณสมบัติและพฤติกรรมของ Object ที่เราต้องการสร้างขึ้น เราสามารถสร้าง Object จากคลาสได้หลายตัว โดยแต่ละ Object จะมีคุณสมบัติและพฤติกรรมที่แตกต่างกันไปได้
การเขียนโปรแกรมเชิงวัตถุจะมีพื้นฐานหลัก 4 อย่าง ได้แก่ Encapsulation (การซ่อนรายละเอียด), Inheritance (การสืบทอดคุณสมบัติ), Polymorphism (การแสดงพฤติกรรมหลายรูปแบบ) และ Abstraction (การบอกถึงคุณสมบัติที่สำคัญ)
  - Shared Features & Functionality
    - คุณสมบัติและฟังก์ชันที่ใช้ร่วมกันได้ในระบบหรือแอปพลิเคชันที่มีหลายๆ โมดูล หรือ component ต่างๆ โดยที่ไม่จำเป็นต้องเขียนฟังก์ชันซ้ำกันหลายครั้ง ซึ่งจะช่วยประหยัดเวลาและลดความซับซ้อนของโค้ดได้
    - Knowing the location of the associated turtle
      - การระบุตำแหน่งของเต่าที่เกี่ยวข้อง
    -  Sending control input to turtlesim
      - การส่งควบคุมเข้าไปยังการจำลองเต่า (Turtle sim) เพื่อทำให้เต่าเคลื่อนที่ตามที่เราต้องการ
    - Using the same control law
      - การใช้กฎควบคุมเดียวกัน (Using the same control law) เป็นการใช้กฎหรือสมการเดียวกันในการควบคุมระบบหลายๆ ระบบ โดยที่กฎหรือสมการนั้นเป็นเหมือนกันทุกเครื่องหมาย ทำให้สามารถลดความซับซ้อนของการพัฒนาระบบได้ นอกจากนี้ยังช่วยให้การจัดการและบำรุงรักษาระบบที่ใช้กฎเดียวกันเป็นเรื่องง่ายขึ้นด้วย
  - Object-Oriented Programming
    - PositionController
      - อุปกรณ์หรือโปรแกรมที่ใช้สำหรับควบคุมตำแหน่งของวัตถุในระบบหนึ่ง ๆ เพื่อให้วัตถุเคลื่อนที่ไปสู่ตำแหน่งที่กำหนดไว้ โดยใช้ค่าตำแหน่งปัจจุบันของวัตถุและค่าตำแหน่งที่ต้องการให้วัตถุเคลื่อนที่ไปถึง เพื่อคำนวณหาความเร็วและทิศทางของการเคลื่อนที่ที่เหมาะสมเพื่อให้วัตถุเคลื่อนที่ไปสู่ตำแหน่งที่ต้องการได้อย่างแม่นยำ
      - subscribe to a turtle's pose
        - การติดตามการเปลี่ยนแปลงตำแหน่งและทิศทางของ turtle ในเวลาที่เกิดขึ้น โดย turtle ใน ROS จะทำหน้าที่ publish ข้อมูล pose ของ turtle ออกมา ซึ่งสามารถ subscribe ไปยัง topic นี้เพื่อรับข้อมูล pose ของ turtle ที่มีการเปลี่ยนแปลงได้โดยตลอดเวลา
      - publish Twist message to command velocity
        - การ publish Twist message เพื่อควบคุมความเร็วและทิศทางของ turtlebot ใน ROS สามารถทำได้โดยการสร้างโปรแกรม ROS ที่สามารถ publish ข้อความใน topic ของ command velocity ของ turtlebot ได้
      - have its internalstate machine
        - การเก็บข้อมูลสถานะภายในโปรแกรม ซึ่งช่วยให้โปรแกรมสามารถตรวจสอบสถานะของตัวเองและปรับการทำงานได้อย่างเหมาะสมตามสถานการณ์
    - TurtleFollower
      - เป็นโปรแกรมที่ใช้ในการควบคุม Turtlebot เพื่อทำให้ติดตามเส้นทางหรือวัตถุต่างๆ ได้อย่างมีประสิทธิภาพ
      - subscribe to a turtle's pose
        - การรับข้อมูลตำแหน่งและทิศทางของ turtle โดยใช้โปรแกรม ROS (Robot Operating System) ซึ่งเป็นระบบซอฟต์แวร์เพื่อควบคุมและควบคุมการเคลื่อนที่ของหุ่นยนต์
การ subscribe จะเป็นการรับข้อมูลจาก topic ที่เกี่ยวข้องกับตำแหน่งและทิศทางของ turtle โดยโปรแกรมจะเป็นผู้ subscribe ไปยัง topic นั้นๆ เพื่อรับข้อมูลที่ส่งมาจาก turtle โดย topic ที่เกี่ยวข้องกับ turtle's pose ใน ROS จะเป็น "/turtle1/pose" โดยที่ "turtle1" คือชื่อ turtle และ "pose" คือชื่อ topic ที่เกี่ยวข้องกับตำแหน่งและทิศทางของ turtle
      - ViaPointFollower
        - โปรแกรมใน ROS (Robot Operating System) ที่มีไว้สำหรับควบคุมการเคลื่อนที่ของหุ่นยนต์ โดยจะติดตามจุดในพื้นที่ ซึ่งเรียกว่า "via points" เพื่อเข้าไปยังจุดหมายปลายทาง
โดยการทำงานของ ViaPointFollower จะมีการสร้าง state machine หรือเครื่องมือควบคุมเคลื่อนที่ของหุ่นยนต์ ซึ่งสามารถแสดงสถานะและการทำงานของหุ่นยนต์ได้ในแต่ละช่วงของการเคลื่อนที่ เช่น การติดตามจุด, การหันหน้า, การเดินหน้า, หรือการหยุดนิ่ง เป็นต้น
การทำงานของ ViaPointFollower จะมีการ subscribe ไปยัง topic ที่เกี่ยวข้องกับ turtle's pose เพื่อรับข้อมูลตำแหน่งและทิศทางของ turtle โดยสามารถเข้าถึงได้ผ่าน "/turtle1/pose" ซึ่งเป็นชื่อ topic ที่เกี่ยวข้องกับ turtle ที่เราต้องการควบคุม
          - subscribe to a point
            - การรับข้อมูลจาก topic ที่เกี่ยวข้องกับ point โดยจะมีโปรแกรมหรือโมดูลที่ทำหน้าที่ subscribe เพื่อรับข้อมูล point และทำการประมวลผลหรือใช้ข้อมูลดังกล่าวในการควบคุมหรือปรับปรุงการทำงานของระบบ
เพื่อ subscribe ไปยัง point ใน ROS โดยทั่วไปจะใช้ไลบรารี่ rospy ซึ่งเป็นไลบรารี่ที่ใช้สำหรับการพัฒนาโปรแกรมใน ROS โดยโปรแกรมที่ต้องการ subscribe จะต้องกำหนดชื่อ topic ที่ต้องการรับข้อมูล และต้องระบุ callback function ซึ่งจะถูกเรียกเมื่อมีข้อมูลใหม่เข้ามาทาง topic นั้นๆ

- Topic >> Remapping & namespace
  - การเปลี่ยนชื่อ topic หรือ service ให้เป็นชื่ออื่นที่ต้องการ เพื่อให้โมดูลหรือโปรแกรมที่เชื่อมต่อกับ ROS สามารถเรียกใช้งาน topic หรือ service นั้นๆ ได้ตามชื่อที่ต้องการ โดยไม่จำเป็นต้องเปลี่ยนชื่อในโปรแกรมหรือโมดูลนั้นๆ
  - Inconsistent topic names
    - การใช้ชื่อ topic ที่ไม่สอดคล้องกันระหว่าง publisher และ subscriber ใน ROS ซึ่งอาจเกิดปัญหาในการเชื่อมต่อและสื่อสารระหว่างโปรแกรมหรือโมดูลต่างๆ ที่ใช้ ROS เพราะไม่สามารถระบุชื่อ topic ที่ถูกต้องได้
  - Remapping Topics
    - การเปลี่ยนชื่อ topic ของ publisher หรือ subscriber เพื่อให้เหมาะสมกับการใช้งานหรือการเชื่อมต่อกับโปรแกรมหรือโมดูลอื่นๆ การ remapping topics นั้นสามารถทำได้ผ่าน command-line หรือ launch file โดยการกำหนดชื่อเดิมและชื่อใหม่ของ topic ที่ต้องการเปลี่ยนแปลง
    - Outside of our code, we can "remap" the name of the topic in the command line.
      - เราสามารถ "remap" ชื่อของ topic ใน command line ได้ หมายถึงการเปลี่ยนชื่อของ topic ที่เราต้องการเชื่อมต่อในระหว่างการรันโปรแกรม โดยไม่ต้องแก้ไขโค้ดภายในโปรแกรม
    - In the code, we can change the subscribed topic to "pose" instead of using "/turtle1/pose".
      - ในโค้ดของเรา เราสามารถเปลี่ยนการ subscribe topic จาก "/turtle1/pose" เป็น "pose" ได้ โดยการใช้ remap ใน constructor ของ Subscriber object
    - We can apply the same idea to other topics.
      - เราสามารถนำแนวคิดเดียวกันมาใช้กับ topic อื่นๆ ได้เช่นกัน โดยการ remap topic ใน constructor ของ Subscriber หรือ Publisher object ตามที่เหมาะสม
    - In the command line, we can add arguments at the end.
      - ใน command line เราสามารถเพิ่ม argument ได้ที่ส่วนท้ายของคำสั่ง โดยการใช้ flag หรือ option ต่างๆ ที่เหมาะสม
  - Having the same type of nodes in ROS network
    - การมีประเภทเดียวกันของ nodes ใน ROS network สามารถช่วยให้การทำงานของระบบเป็นไปได้อย่างเป็นระบบและมีประสิทธิภาพมากขึ้น โดยสามารถทำได้โดยการเขียน nodes ที่มีลักษณะและพฤติกรรมที่เหมือนกันในแต่ละส่วนของระบบ
  - Distinguishing topics using namespace
    - ใน ROS การใช้ Namespace เป็นวิธีหนึ่งในการจัดกลุ่ม Nodes และ Topics ในลักษณะแบบชั้นโครงสร้างเพื่อเป็นการแยกแยะ Topic ที่มีชื่อเหมือนกันและป้องกันการขึ้นชื่อทับกัน
ตัวอย่างเช่น หากเรามีสอง Nodes ที่เผยแพร่ Topic ชื่อ "data" เราสามารถใช้ Namespace ต่างกันเพื่อแยกต่างหาก Topic ได้ เราจะใช้ Namespace ต่อไปนี้สำหรับแต่ละ Node
  - Topic with Namespace
    - ใน ROS มีการใช้ namespace เพื่อจัดกลุ่ม topic ที่เกี่ยวข้องกันในเครือข่าย ROS เช่นเดียวกับโครงสร้างไดเรกทอรีของระบบไฟล์ของคอมพิวเตอร์ โดย namespace จะช่วยให้เราสามารถระบุชื่อ topic ได้โดยใช้ชื่อที่ไม่ซ้ำกันภายใน ROS เช่นเดียวกับการใช้ชื่อไดเรกทอรีในระบบไฟล์
    - One can also add "namespace" to an entire node, which appendsthe namespace to the front of every name without "/" in the front.
      - ใน ROS สามารถเพิ่ม "namespace" ให้กับโหนดทั้งหมดได้ เพื่อให้ได้ชื่อที่ถูกต้องโดยอัตโนมัติโดยการเติม namespace ไปยังชื่อทุกชื่อที่ไม่มี "/" อยู่ข้างหน้า โดยที่ไม่จำเป็นต้องเพิ่ม namespace ให้แต่ละ topic แยกต่างหาก

- Topic >> Service Server & Service Client
  - Service Server และ Service Client เป็นส่วนหนึ่งของ ROS (Robot Operating System) ที่ใช้สำหรับการสื่อสารแบบบริการ (service-oriented communication) ซึ่งใช้แบบ request-response หรือ การขอ-ตอบ
Service Server เป็นโค้ดที่รับ request จาก Service Client และทำการตอบกลับด้วย response ซึ่งสามารถกำหนดฟังก์ชัน callback เพื่อจัดการ request และ response ตามที่ต้องการได้
Service Client เป็นโค้ดที่ส่ง request ไปยัง Service Server และรอรับ response กลับมา โดยสามารถเรียกใช้งานได้หลายครั้งและรอรับ response จาก Service Server หลังจากส่ง request
การใช้งาน Service Server และ Service Client สามารถนำมาประยุกต์ใช้ในงานต่างๆ เช่นการส่งข้อมูล sensor จากหุ่นยนต์ การเรียกใช้งานบริการหาเส้นทางจากหน้าจอควบคุม หรือการใช้งานบริการเพื่อคำนวณข้อมูลต่างๆ ของหุ่นยนต์
  - Attaching a service server and its callback
    - เพื่อที่จะทำการแนบเซอร์วิสเซิร์ฟเวอร์และคอลแบ็กของมันใน ROS
  -  Custom Interface
    - การสร้าง Custom Interface ใน ROS นั้นเป็นการกำหนดข้อมูลที่จะถูกส่งและรับรองรับโดยโปรแกรมใน ROS ทั้งหมด โดยปกติแล้ว ROS จะมี Interface พื้นฐานที่ใช้กันอยู่แล้ว เช่น Service ที่ใช้สำหรับการร้องขอข้อมูลจาก Node อื่น ๆ และ Publisher/Subscriber ที่ใช้สำหรับการส่งข้อมูลระหว่าง Node แต่ถ้าหาก Interface พื้นฐานเหล่านี้ไม่เพียงพอสามารถสร้าง Custom Interface เพิ่มเติมได้ตามความต้องการของโปรแกรม
    - Interface name muststart with uppercase letter and must not contain underscore or other unique characters. The 
field itself muststart with lowercase letter.
      - ชื่อ Interface จะต้องขึ้นต้นด้วยตัวอักษรพิมพ์ใหญ่และไม่ควรมีเครื่องหมายขีดล่างหรือตัวอักษรพิเศษอื่นๆ เขตตัวแปรของ Interface ต้องขึ้นต้นด้วยตัวอักษรพิมพ์เล็ก
  - Package with custom interface
    - การสร้างแพ็กเกจที่มี Custom Interface ใน ROS
  - CMakeLists.txt (custom interface)
    - ใน ROS, ไฟล์ CMakeLists.txt ใช้สำหรับการกำหนดการติดตั้งแพคเกจ หรือเมื่อเราต้องการใช้งาน custom interface ในแพคเกจของเรา เราจะต้องแก้ไขไฟล์ CMakeLists.txt เพื่อให้ ROS สามารถตรวจจับไฟล์ custom interface และสร้างไฟล์ของเม็ดเงินเพื่อใช้ในการสร้าง code สำหรับ ROS nodes ต่างๆ โดยไฟล์ CMakeLists.txt
  - package.xml (custom interface)
    - ไฟล์ package.xml ใช้สำหรับระบุข้อมูลของแพ็กเกจ ROS โดยปกติแล้วจะต้องระบุชื่อแพ็กเกจ และรายละเอียดอื่นๆ เช่น ผู้เขียน ผู้สนับสนุน และไลบรารีที่ใช้ โดยเฉพาะถ้าแพ็กเกจมีการใช้ custom interface ก็จะต้องระบุเป็นไฟล์ dependency ด้วย
  - Custom Interface for our turtlesim
    - สร้างอินเตอร์เฟซแบบกำหนดเองสำหรับ turtlesim ของเรา
  - custom service
    - การกำหนดบริการที่เหมาะสมสำหรับการใช้งานที่ต้องการเฉพาะ ระบบ ROS ช่วยให้ผู้ใช้สามารถสร้างบริการที่กำหนดเองได้ที่นิยมใช้สำหรับการกำหนดพฤติกรรมเฉพาะ เช่น การขอข้อมูลจากเซ็นเซอร์ การเรียกใช้การเคลื่อนไหวของหุ่นยนต์หรือการเปลี่ยนแปลงการกำหนดค่าของหุ่นยนต์
  - Synchronous vs Asynchronous Programming
    - Synchronous
      - การเขียนโปรแกรมแบบ Synchronous จะทำให้โปรแกรมมีการทำงานเป็นลำดับ โดยจะต้องรอให้โปรแกรมส่วนหนึ่งทำงานเสร็จก่อน ถึงจะเริ่มทำงานส่วนต่อไปได้ ซึ่งจะใช้เวลานานในการรอ และอาจทำให้โปรแกรมทำงานช้าลง
    - Asynchronous
      - ส่วน Asynchronous จะทำให้โปรแกรมมีการทำงานได้หลายอย่างพร้อมกัน โดยไม่ต้องรอให้ส่วนหนึ่งทำงานเสร็จก่อน ซึ่งจะช่วยให้โปรแกรมทำงานได้เร็วขึ้น แต่ก็อาจเกิดปัญหาเนื่องจากการทำงานแบบ Asynchronous จะทำให้การจัดการกับข้อมูลและความผิดพลาดเป็นไปได้หลากหลายมากขึ้น
  - Future Object (RCLPY)
    - ใน RCLPY มีคลาส Future ที่เป็นตัวแทนของค่าที่ยังไม่สามารถหาได้ในปัจจุบัน แต่อาจจะได้รับในอนาคต เมื่อมีค่าให้ Future แล้ว การเรียกใช้ method get() ของ Future จะรอการคืนค่าจนกว่าค่าจะมาถึง หากค่ามาถึงแล้ว get() จะคืนค่านั้นออกไป แต่หากยังไม่มีค่า get() จะเรียกใช้งานได้อย่างเป็น blocking และรอจนกว่าค่าจะมาถึง ในขณะที่รอ Future เราสามารถทำงานอื่นไปได้ ซึ่งจะช่วยให้เราใช้งานแบบ asynchronous ได้ง่ายขึ้น
  - Attaching a service client
    - การเชื่อมต่อ service client เป็นการสร้างอ็อบเจ็กต์ของ client และระบุชื่อของ service และประเภทของ service ที่จะใช้ หลังจากสร้าง client เรียบร้อยแล้ว สามารถใช้งาน client เพื่อเรียกใช้ service ด้วยอาร์กิวเมนต์ที่เหมาะสมได้
  - Time-driven vs. Event-driven
    - การเขียนโปรแกรมสามารถแบ่งออกเป็นสองแนวทางหลักได้แก่ การเขียนโปรแกรมแบบเวลาเป็นตัวกำหนด (time-driven) และการเขียนโปรแกรมแบบเหตุการณ์เป็นตัวกำหนด (event-driven) โดยแนวทางการเขียนโปรแกรมแบบเวลาเป็นตัวกำหนดจะให้การควบคุมเป็นไปตามเวลาที่กำหนดไว้ เช่น การทำงานที่บ้านและที่ทำงานจะต่างกัน เพราะเวลาเป็นตัวกำหนดในการทำงานของทั้งสองสถานที่ ในขณะที่แนวทางการเขียนโปรแกรมแบบเหตุการณ์เป็นตัวกำหนดจะทำงานตามเหตุการณ์ที่เกิดขึ้น เช่น การทำงานในระบบเครือข่ายจะต้องรอให้เกิดเหตุการณ์เช่นการเชื่อมต่อก่อนที่จะทำงานต่อไป หรือรอให้มีข้อมูลเข้ามาจากเซนเซอร์ก่อนที่จะทำการประมวลผลต่อไป
  - Waiting for a task to complete
    - การรอให้งานเสร็จสิ้นเป็นเรื่องที่สำคัญในการโปรแกรมแบบแบ่งเวลาหรือ time-driven ซึ่งต้องการรอให้งานที่กำหนดเวลาเสร็จสิ้นก่อนที่จะดำเนินการต่อไป เช่น การรอให้ข้อมูลถูกส่งกลับจากเว็บเซิร์ฟเวอร์ หรือการรอให้การทำงานสิ้นสุดของกระบวนการในภาษา Python
    - What if instead of only setting a goal, we also wait for the turtle to reach the goal ?
      - ในการรอให้เต่าถึงจุดหมายเป้าหมาย โดยใช้ฟังก์ชัน wait_for_result() ที่ให้ไว้ใน ROS แบบ Action จะช่วยให้โปรแกรมรอให้เต่าถึงจุดเป้าหมายก่อนที่จะทำงานอื่นต่อไป ซึ่งการใช้ฟังก์ชันนี้จะเป็นแบบ Synchronous โดยจะรอจนกว่า Action จะสมบูรณ์หรือจนกว่าจะหมดเวลาที่กำหนดไว้
    - When it reachesthe goal, itshould return the total distance (Euclidean).
      - เมื่อเครื่องหรือสิ่งของใดไปถึงจุดหมายที่กำหนดไว้แล้ว ต้องคืนค่าระยะทางรวม (ยูคลิเดียน) ทั้งหมดของการเคลื่อนที่ไปยังจุดหมายนั้นๆ เป็นคำแสดงความว่าเมื่อมีการนำเครื่องหรือสิ่งของไปถึงจุดหมายที่กำหนดไว้แล้ว จะต้องคำนวณหรือวัดระยะทางรวมที่เคลื่อนที่ไปยังจุดหมายนั้นๆ โดยใช้วิธีการวัดระยะ Euclidean ซึ่งเป็นวิธีการวัดระยะทางในระบบพิกัดแบบสองมิติ โดยใช้เป็นระยะทางแบบตรงระหว่างจุดสองจุดในพื้นที่ 2 มิติ ที่สัมพันธ์กันโดยใช้ระบบพิกัด (x,y)
    - In the meantime, itshould publish the elasped time.
      - ในขณะเดียวกัน ควรเผยแพร่เวลาที่ผ่านไป
- Topic >> Action, Callback Group, & Multithread Execution
  - การกระทำ (Action), กลุ่มการเรียกคืน (Callback Group), และการดำเนินการหลายเธรด (Multithread Execution)
  - Action & Single Thread Execution
    - การกระทำ (Action) และการดำเนินการในเธรดเดียว (Single Thread Execution)
  - Deadlock
  - Multithread Execution
    - การดำเนินการหลายเธรด
  - Callback Groups

# Lecture 2 : Launch Engineering
- Topic >> Launch Script & Launch Action
  - สคริปเปิดใช้งาน (Launch Script) และการกระทำเปิดใช้งาน (Launch Action)
  - Launch Filesin ROS2
    - ไฟล์เปิดใช้งาน (Launch Files) ใน ROS2
    - A (ROS2) Launch file allows a user to run a system with multiple ROS nodes or other launch files at once. One can also scheduling the system's behavior as well.
      - ไฟล์เปิดใช้งาน (Launch Files) ของ ROS2 ช่วยให้ผู้ใช้สามารถเรียกใช้ระบบที่ประกอบด้วยโหนดหลายๆ โหนดของ ROS หรือไฟล์เปิดใช้งานอื่นๆ พร้อมกันได้ นอกจากนี้ยังสามารถกำหนดตารางเวลาเพื่อควบคุมพฤติกรรมของระบบได้อีกด้วย
  - Writing Launch file in ROS(1)
    - เขียนไฟล์เปิดใช้งาน (Launch file) ใน ROS1
  - Writing Launch file in ROS2 with XML
    - เขียนไฟล์เปิดใช้งาน (Launch file) ใน ROS2 ด้วย XML
  - XML Launch file Structure
    - โครงสร้างของไฟล์เปิดใช้งาน (Launch file) ในรูปแบบ XML
  - Python Launch File Structure
    - โครงสร้างของไฟล์เปิดใช้งาน (Launch file) ในรูปแบบ Python
  - Executing command in Launch Script
    - การดำเนินคำสั่งในสคริปเปิดใช้งาน (Launch Script)
  - Package Layout
    - โครงสร้างแพคเกจ (Package Layout)
- Topic >> Executable Arguments & ROS2 Parameters
  - อาร์กิวเมนต์ของโปรแกรมที่สามารถเรียกใช้งานได้และพารามิเตอร์ของ ROS2
  - Arguments & Parameters of a ROS Node
    - อาร์กิวเมนต์และพารามิเตอร์ของโหนดใน ROS
    - "ROS2 Parameter(s)" is designed to be adjustable during runtime.
      - พารามิเตอร์ของ ROS2" ถูกออกแบบมาเพื่อให้สามารถปรับเปลี่ยนได้ระหว่างการทำงาน (runtime)
    - "Argument(s)" of an executable is assigned and used at the beginning of the execution.
      - "อาร์กิวเมนต์" ของโปรแกรมที่สามารถเรียกใช้งานได้ถูกกำหนดและใช้งานที่จุดเริ่มต้นของการทำงาน
  - ROS2 Parameters
    - พารามิเตอร์ของ ROS2
    - Instead of being a standalone value in a ROS network, ROS2 Parameters must be associated with a node.
      - ใน ROS2 Parameters ไม่ใช่ค่าแบบเดี่ยวของระบบ ROS แต่จะต้องถูกผูกกับโหนด (node) เพื่อใช้งาน
    - One can declare parameters in rclpy.Node
      - สามารถประกาศพารามิเตอร์ใน rclpy.Node
  - Assigning Parameters and Argumentsin Launch File
    - กำหนดค่าพารามิเตอร์และอาร์กิวเมนต์ในไฟล์เปิดใช้งาน (Launch File)
- Topic >> Data Deserialization
  - การแปลงข้อมูลกลับเป็นรูปแบบเดิม (Data Deserialization)
  - Passing Parameters Manually
    - การส่งพารามิเตอร์ด้วยวิธีกำหนดเอง (Passing Parameters Manually)
  - Automatic Deserialization from YAML file
    - การแปลงข้อมูลอัตโนมัติจากไฟล์ YAML (Automatic Deserialization from YAML file)
  - YAML Formatfor ROS2 Parameters
    - รูปแบบ YAML สำหรับพารามิเตอร์ ROS2
ใน ROS2 มีการใช้ YAML เป็นรูปแบบสำหรับการกำหนดค่าพารามิเตอร์ (parameters) ซึ่งเป็นไฟล์ข้อความที่ใช้ในการกำหนดค่าต่าง ๆ ของโหนด (node) ใน ROS2 โดยทั่วไปแล้ว YAML จะถูกใช้ในการกำหนดค่าพารามิเตอร์ที่มีขนาดใหญ่และมีโครงสร้างที่ซับซ้อน เช่น พารามิเตอร์สำหรับคอนฟิกของหุ่นยนต์
  - get_package_share_directory
    - get_package_share_directory เป็นฟังก์ชันใน ROS2 ที่ใช้ในการดึงตำแหน่งของไดเรกทอรี share ของแพ็กเกจ (package) ที่กำลังใช้งานอยู่ เพื่อให้สามารถเข้าถึงไฟล์ที่เก็บอยู่ในไดเรกทอรีนั้นได้อย่างสะดวก
    - To get the full path to the file, one must get the path to the "installed" package [NOT the 
one in src].
      - หากต้องการรับเส้นทางที่แน่นอนของไฟล์ที่เก็บในแพ็กเกจ (package) ใน ROS2 จะต้องดึงตำแหน่งของไดเรกทอรีที่ติดตั้งแล้ว (installed package) ไม่ใช่ตำแหน่งของไดเรกทอรีใน src ที่อยู่ในโฟลเดอร์ของโปรเจ็กต์ ROS2 ของเรา.
การติดตั้งแพ็กเกจจะนำเข้าโค้ดและไฟล์ของแพ็กเกจนั้น ๆ เข้าสู่ไดเรกทอรีของ ROS2 ซึ่งสามารถหาได้โดยใช้คำสั่ง rospack find หรือ ament find โดย ament เป็นคำสั่งใน ROS2 ที่ใช้ค้นหาแพ็กเกจที่ติดตั้งแล้วโดยอัตโนมัติ
    - "get_package_share_directory" allows the software to automatically return the full path to 
the path with the given name.
      - ฟังก์ชัน get_package_share_directory ใน ROS2 ช่วยให้ซอฟต์แวร์สามารถคืนค่าเส้นทางแบบอัตโนมัติไปยังไดเรกทอรี share ของแพ็กเกจ (package) ที่ระบุไว้
    - "os.path.join" append the string together as an appropriate path (with /).
      - ฟังก์ชัน os.path.join ใน Python ช่วยให้เราสามารถเชื่อมต่อเส้นทาง (path) ของไฟล์หรือไดเรกทอรีในระบบไฟล์ของเครื่องคอมพิวเตอร์ โดยอัตโนมัติเลือกตัวแบ่งเส้นทางที่ถูกต้องตามระบบปฏิบัติการที่ใช้งานอยู่ ซึ่งในระบบปฏิบัติการ Windows จะใช้ \ และใน macOS หรือ Linux จะใช้ /

- Topic >> Namespace Management
  - การจัดการเนมสเปซ (Namespace Management) ใน ROS2 เป็นการจัดการการใช้ชื่อ (name) ของโหนด (node) และอ็อบเจ็กต์ (object) ใน ROS2 ให้เป็นระเบียบและเหมาะสมกับงานที่ต้องการทำ โดยการใช้งาน Namespace ใน ROS2 จะช่วยให้เราสามารถกำหนดชื่ออ็อบเจ็กต์หรือโหนดได้อย่างเหมาะสมกับงานและมีความสอดคล้องกันในระบบ.
โดย Namespace ใน ROS2 จะมีการใช้งานอยู่ 2 รูปแบบ ได้แก่ Private Namespace และ Global Namespace.
Private Namespace จะเป็นการกำหนดชื่อในขอบเขตของโหนด โดยใช้ขีดล่าง (_) ในการเรียกชื่อโหนด ตัวอย่างเช่น หากมีโหนดชื่อ my_node และต้องการกำหนดชื่ออ็อบเจ็กต์เป็น my_object ภายในโหนด my_node จะใช้ Private Namespace โดยใช้ชื่อ my_node/my_object.
Global Namespace จะเป็นการกำหนดชื่อที่เหมือนกันในทุกๆโหนดในเครือข่าย ROS2 โดยใช้เครื่องหมาย / ในการเรียกชื่อโหนด ตัวอย่างเช่น ชื่อโหนด my_node ใน Global Namespace จะเรียกว่า /my_node
การจัดการเนมสเป็นส่วนสำคัญในการออกแบบและพัฒนาระบบ ROS2 โดยจะช่วยให้เราสามารถจัดการชื่อให้สอดคล้องกับโครงสร้างระบบได้อย่างมีประสิทธิภาพและเหมาะสมกับงานที่ต้องการทำ
  - Name
    - Name หมายถึงชื่อหรือตัวระบุของอ็อบเจ็กต์ (object) ใน ROS2 โดย Name จะถูกใช้เพื่อระบุตำแหน่งของอ็อบเจ็กต์ใน ROS2 โดยมีการใช้งาน Name ในหลายๆ ส่วนของ ROS2 เช่น ชื่อโหนด (node) ชื่อเซอร์วิส (service) ชื่อโปรแกรม (package) เป็นต้น.
การตั้งชื่อให้ถูกต้องและเหมาะสมเป็นสิ่งสำคัญในการออกแบบและพัฒนาระบบ ROS2 เพราะชื่อจะช่วยให้เราสามารถระบุตำแหน่งของอ็อบเจ็กต์ได้อย่างถูกต้อง โดยสามารถใช้งาน Name ในหลายๆ รูปแบบ เช่น Private Namespace และ Global Namespace เพื่อให้ชื่อมีความสอดคล้องกับโครงสร้างระบบและงานที่ต้องการทำ
นอกจากนี้การตั้งชื่อให้ถูกต้องและเหมาะสมยังช่วยให้ง่ายต่อการเข้าใจและการใช้งานของระบบ ROS2 โดยผู้ใช้งานสามารถระบุตำแหน่งของอ็อบเจ็กต์ได้อย่างง่ายดาย และไม่ต้องสับสนในการเรียกใช้งานในตอนต่อไป
      - Absolute name refers to a name that cannot be modified by other name token.
        - Absolute name หมายถึงชื่อที่ไม่สามารถแก้ไขได้โดย Name token อื่น ๆ ใน ROS2 นั่นคือชื่อที่ถูกกำหนดไว้และไม่มีวิธีการเปลี่ยนแปลง ซึ่งจะช่วยให้เราสามารถระบุตำแหน่งของอ็อบเจ็กต์ใน ROS2 ได้อย่างถูกต้องและสามารถใช้งานได้เหมือนเดิมตลอดเวลา.
การใช้งาน Absolute name มักจะใช้ในกรณีที่ต้องการระบุตำแหน่งของอ็อบเจ็กต์ใน ROS2 แบบแน่นอน โดยไม่มีความเปลี่ยนแปลงใดๆ ทั้งสิ้น เช่น ในการระบุตำแหน่งของโหนด (node) หรือเซอร์วิส (service) ที่ต้องการใช้งานโดยต้องระบุชื่ออย่างแน่นอน.
การใช้งาน Absolute name นอกจากจะช่วยให้เราระบุตำแหน่งของอ็อบเจ็กต์ได้อย่างถูกต้องแล้ว ยังช่วยให้เราสามารถเรียกใช้งานอ็อบเจ็กต์ที่ต้องการได้ง่ายขึ้น และลดความสับสนในการใช้งานของระบบ ROS2
          - Topic : /pose
            - Topic ชื่อ /pose ใน ROS2 เป็นหนึ่งใน Topic ที่สามารถใช้งานได้แบบ Real-time ซึ่งใช้สำหรับส่งข้อมูลตำแหน่ง (Position) และทิศทาง (Orientation) ของอ็อบเจ็กต์ (Object) จากหนึ่งโหนด (Node) ไปยังโหนดอื่นๆ ในระบบ ROS2.
Topic ชื่อ /pose นั้นมักจะถูกใช้งานในหลายๆ แอปพลิเคชัน ROS2 เพื่อให้สามารถรับ-ส่งข้อมูลตำแหน่งและทิศทางของอ็อบเจ็กต์ระหว่างโหนดได้อย่างมีประสิทธิภาพ ในการใช้งานจริง เราสามารถตั้งชื่อ Topic ตามที่เราต้องการได้ แต่ /pose เป็นชื่อ Topic ที่นิยมใช้งานมากในโครงการ ROS2 ด้วยความสามารถของ Topic นี้ในการควบคุมการเคลื่อนไหวของหุ่นยนต์หรือโดรนได้อย่างมีประสิทธิภาพและแม่นยำ
      - Relative name refers to a name that can be modified by other name token.
        -  ชื่อที่เป็นแบบ "Relative name" ใน ROS2 คือชื่อที่สามารถปรับเปลี่ยนได้โดย token ชื่ออื่น ๆ ภายในที่อยู่ namespace เดียวกัน ซึ่ง namespace ใน ROS2 คือกลุ่มของโหนด (Node) ที่เรียงต่อกันโดยมีเครื่องหมาย / คั่นระหว่างชื่อโดเมน (domain) กับชื่อโหนด (Node) เช่น /my_domain/my_node

        - การใช้ Relative name นั้นช่วยให้เราสามารถเข้าถึง Topic หรือ Node ได้อย่างสะดวกสบายโดยไม่ต้องระบุที่อยู่ของ Node หรือ Topic ทั้งหมดในชื่อ ในการเข้าถึง Relative name นั้นจะใช้เครื่องหมายจุด (.) ในการเชื่อมต่อชื่อของ Node หรือ Topic ใน Namespace เดียวกัน ยกตัวอย่างเช่นถ้าเรามี Node ชื่อ my_node ภายใต้ Domain ชื่อ my_domain และมี Topic ชื่อ my_topic ภายใต้ Node ดังกล่าว ในการเข้าถึง Topic นั้นเราสามารถใช้ชื่อที่เป็น Relative name ได้เช่น my_node.my_topic โดยไม่ต้องระบุ Namespace ตั้งแต่ต้น
        -  Topic : pose
            - Topic ใน ROS2 เป็นช่องทางในการสื่อสารระหว่าง Node ซึ่งสามารถส่งข้อมูลได้ในรูปแบบของ message ต่าง ๆ โดยเฉพาะอย่างยิ่งในการควบคุมหุ่นยนต์หรือการติดตามตำแหน่งของหุ่นยนต์

            - Topic ชื่อ pose นั้นอาจมีหลายๆ แบบกันในแต่ละโปรเจ็กต์ขึ้นอยู่กับว่าผู้พัฒนาได้ตั้งชื่อไว้อย่างไร โดยทั่วไปแล้ว Topic ชื่อ pose จะใช้ในการสื่อสารข้อมูลเกี่ยวกับตำแหน่ง และทิศทางหรือการหมุนของหุ่นยนต์ เช่น ตำแหน่ง x, y, z และความเร็วและองศาของการหมุน (Roll, Pitch, Yaw) ของหุ่นยนต์ ในการเข้าถึง Topic ชื่อ pose นั้นสามารถใช้คำสั่ง rostopic หรือเขียนโค้ด Node ในภาษา Python หรือ C++ เพื่อส่งหรือรับข้อมูลผ่าน Topic ได้ตามต้องการ
      - Private name refers to a name that will be automatically add its associated node in front.
        - ใน ROS2 มีการใช้ Private Namespace เพื่อช่วยในการจัดการ Namespace ในกรณีที่มี Node หลายๆ ตัวที่มีชื่อ Topic หรือ Service ซ้ำกัน โดย Private Namespace จะเป็นการเพิ่ม prefix ของชื่อ Node ที่เรียกใช้งาน Topic หรือ Service ต่างๆ เพื่อให้ชื่อเหล่านั้นไม่ซ้ำกัน

        - เมื่อเราสร้าง Node ใน ROS2 แล้ว จะมีการกำหนดชื่อ Node ได้ เช่น my_node ถ้าหากเราต้องการใช้ Private Namespace เราสามารถเพิ่ม _ ไปหลังชื่อ Node เพื่อให้เป็น Private Namespace ได้ เช่น my_node_ ดังนั้น Topic ที่มีชื่อว่า /pose จะถูกแทนด้วย /my_node_/pose โดย Private Namespace นั้นจะถูกเพิ่มให้อัตโนมัติต่อท้ายชื่อ Topic หรือ Service เมื่อ Node นั้นๆ เข้าถึงในส่วนของ Topic หรือ Service นั้นๆ และ Private Namespace นั้นจะช่วยลดความซ้ำซ้อนของชื่อ Topic หรือ Service ในระบบ ROS2
        - Topic : ~/pose
          - ใน ROS2 มีการใช้ Tilde (~) ในการสร้าง Private Namespace ซึ่งเป็นวิธีที่สะดวกและช่วยให้ลดความซ้ำซ้อนของชื่อ Topic หรือ Service ในระบบ ROS2 ได้

          - เมื่อเราสร้าง Node ใน ROS2 แล้ว จะมีการกำหนดชื่อ Node ได้ เช่น my_node ถ้าหากเราต้องการใช้ Tilde (~) เราสามารถเพิ่ม ~ ไปหลังชื่อ Node เพื่อให้เป็น Private Namespace ได้ เช่น /my_node ดังนั้น Topic ที่มีชื่อว่า /pose จะถูกแทนด้วย /pose โดย Tilde () จะถูกเพิ่มให้อัตโนมัติต่อท้ายชื่อ Topic หรือ Service เมื่อ Node นั้นๆ เข้าถึงในส่วนของ Topic หรือ Service นั้นๆ และ Tilde () นั้นจะช่วยลดความซ้ำซ้อนของชื่อ Topic หรือ Service ในระบบ ROS2 อีกด้วย
      - Hidden name refers to a name that will be hidden in ROS API interface.
        - ชื่อที่ซ่อนไว้ (Hidden Name) เป็นชื่อที่จะไม่ปรากฏใน ROS API interface ของ ROS ซึ่งจะถูกนำมาใช้ในกรณีที่ต้องการใช้ชื่อที่ไม่ถูกเผยแพร่หรือเข้าถึงได้ง่าย โดยมักจะใช้สำหรับชื่อ Topic, Service, Parameter หรือ Node เพื่อป้องกันไม่ให้ชื่อเหล่านี้ถูกเข้าถึงจากผู้ใช้งานที่ไม่ได้รับอนุญาตหรือไม่มีสิทธิ์ในการเข้าถึง

        - การกำหนดชื่อที่ซ่อนไว้ใน ROS สามารถทำได้โดยการใช้ prefix ของชื่อด้วยสัญลักษณ์ underscore (_), ตัวอย่างเช่น

        - _my_topic: ชื่อ Topic ที่ถูกซ่อนไว้ เมื่อผู้ใช้งานพยายามเข้าถึงจะไม่พบชื่อนี้ใน ROS API interface

        - _my_service: ชื่อ Service ที่ถูกซ่อนไว้ เมื่อผู้ใช้งานพยายามเรียกใช้งานจะไม่พบชื่อนี้ใน ROS API interface
 
        - การใช้ชื่อที่ซ่อนไว้สามารถช่วยป้องกันการเข้าถึงทรัพยากรต่างๆ ใน ROS จากผู้ใช้งานที่ไม่ได้รับอนุญาตหรือไม่มีสิทธิ์ในการเข้าถึง และช่วยเพิ่มความปลอดภัยให้กับระบบ ROS โดยรวม
        - Topic : _pose
          - Topic ที่ถูกตั้งชื่อว่า _pose จะเป็น Topic ที่ถูกซ่อนไว้ใน ROS API interface ซึ่งอาจถูกใช้สำหรับสื่อสารระหว่าง Node ในระบบ ROS เพื่อส่งหรือรับข้อมูลที่เกี่ยวข้องกับตำแหน่งและทิศทางของวัตถุหรือหุ่นยนต์ในพื้นที่ ซึ่งอาจมีการใช้งานอยู่ในหลายๆ งานต่างๆ เช่น งานทางด้านการสังเคราะห์ภาพ, หุ่นยนต์, และการทำ SLAM (Simultaneous Localization and Mapping) ฯลฯ

          - การใช้ชื่อที่ถูกซ่อนไว้ (_pose) จะช่วยเพิ่มความปลอดภัยให้กับ Topic นี้ โดยไม่ให้ผู้ใช้งานทั่วไปเข้าถึงและแก้ไขข้อมูลที่ส่งหรือรับผ่าน Topic นี้ได้ และต้องมีสิทธิ์ในการเข้าถึงเท่านั้นที่จะสามารถเข้าถึง Topic นี้ได้
    -  Namespace และ Uniform Resource Locators (URL)
      - Namespace ใน ROS คือ การจัดกลุ่มของ Topic, Service, Parameter, Node และ Resource อื่นๆ ในชื่อเดียวกันเพื่อให้สามารถเข้าถึงและจัดการได้ง่ายขึ้น โดยทั่วไปแล้วจะใช้ชื่อเดียวกันสำหรับ Namespace และ Package ของ ROS เพื่อสร้างโครงสร้างของโปรเจค ROS ที่มีความเป็นระเบียบและเข้าใจง่าย

      - Uniform Resource Locators (URL) เป็นตัวบอกที่อยู่ของทรัพยากรบนอินเทอร์เน็ต เช่นเว็บไซต์ ไฟล์ และฐานข้อมูล โดย URL จะประกอบด้วยโพรโตคอล (protocol) เช่น http, https, ftp, โดยมักจะเริ่มต้นด้วยชื่อโดเมน (domain name) หรือ IP address และจบลงด้วย path หรือ query string ที่ใช้ในการกำหนดทรัพยากรที่ต้องการเข้าถึง

      - ใน ROS, URL สามารถใช้เพื่ออ้างอิงถึงทรัพยากรในระบบ ROS เช่น Topic, Service, Parameter ได้ โดย URL จะประกอบด้วย schema ที่ใช้ในการอ้างอิงทรัพยากรใน ROS เช่น "ros", "ros2" หรือ "package" ตามด้วยชื่อ Namespace และชื่อ Topic, Service หรือ Parameter ที่ต้องการอ้างถึง ตัวอย่างเช่น

      - ros2://namespace/topic_name

      - package://package_name/namespace/topic_name

      - RL ที่ใช้ใน ROS สามารถช่วยให้เข้าถึงและจัดการทรัพยากรใน ROS ได้ง่ายขึ้น และช่วยเพิ่มความสะดวกในการอ้างถึงทรัพยากรต่างๆ ใน ROS อีกด้วย
   -  Adding namespace in Launch file
    -  การเพิ่ม Namespace ใน Launch file ใน ROS
        1.เพิ่ม argument ในไฟล์ Launch เพื่อรับค่า Namespace ที่ต้องการ
        2.นำ argument ที่รับค่ามาใช้ในการเรียก Node และ Topic โดยใช้ $(arg my_namespace)
   -  Generalizing YAML for variable namespace
    -  การทำให้ YAML สามารถรองรับ Namespace ที่เปลี่ยนแปลงได้เป็นตัวแปร สามารถทำได้โดยการใช้การ generalize
        1. กำหนดตัวแปร Namespace ที่ต้องการเปลี่ยนแปลงในไฟล์ YAML
        2. กำหนดตัวแปรสำหรับ topic, service และ parameter
   -  Deserialization & Serialization
    -  การ Deserialization และ Serialization เป็นกระบวนการที่ใช้ในการแปลงข้อมูลระหว่างระบบเครือข่ายแบบต่าง ๆ ให้เข้ากันได้ โดยใช้รูปแบบข้อมูลที่เหมาะสมกับแต่ละระบบ เช่น JSON, XML, YAML เป็นต้น

    - การ Deserialization คือกระบวนการแปลงข้อมูลจากรูปแบบที่เหมาะสมกับการส่งข้อมูลผ่านระบบเครือข่าย เช่น JSON, XML, YAML ให้กลายเป็นข้อมูลในรูปแบบของโปรแกรมที่สามารถใช้งานได้ต่อไป เช่น Object, Array, หรือ Primitive Data Type ต่าง ๆ
    - การ Serialization คือกระบวนการแปลงข้อมูลจากรูปแบบของโปรแกรม เช่น Object, Array, หรือ Primitive Data Type ต่าง ๆ ให้เป็นรูปแบบที่เหมาะสมกับการส่งข้อมูลผ่านระบบเครือข่าย เช่น JSON, XML, YAML เพื่อส่งไปยังอุปกรณ์หรือระบบเครือข่ายอื่น ๆ
    - การ Deserialization และ Serialization เป็นกระบวนการสำคัญในการทำงานของ Node ใน ROS โดยจะเป็นการแปลงข้อมูลระหว่างแบบที่รองรับได้และแบบที่สามารถส่งได้เพื่อให้สามารถสื่อสารข้อมูลกันได้อย่างถูกต้องและมีประสิทธิภาพ
   - Group Action
    - Group Action เป็นการทำงานแบบเป็นกลุ่ม (group) ใน ROS ที่มีความซับซ้อนและความยืดหยุ่นสูงกว่า Action แบบธรรมดา ซึ่งสามารถสั่งการหลายๆ ภารกิจพร้อมกันได้ในรูปแบบของ Action Server กลุ่มหรือ Group Action Server

    - Group Action จะมีหลายๆ ภารกิจ (goal) ที่สามารถดำเนินการพร้อมกันได้ แต่การทำงานแต่ละภารกิจอาจมีความซับซ้อนและยากมากขึ้น โดยในแต่ละภารกิจจะมีสถานะเป็นไปได้ 3 สถานะ ได้แก่ Preempted, Active และ Succeeded โดยในการทำงาน Group Action จะมี Goal ID เป็นตัวบอกว่าภารกิจนี้เป็นของกลุ่มใด โดยการส่ง Goal ID ไปยัง Action Server จะทำให้ Action Server รับภารกิจนี้และทำการตรวจสอบว่าภารกิจนี้เป็นของกลุ่มใด และเริ่มการทำงานของภารกิจใน Group Action นั้น

    - Group Action นั้นมีความยืดหยุ่นและสามารถปรับเปลี่ยนได้ตามความต้องการ โดยสามารถสร้าง Action Server กลุ่มที่เหมาะสมกับงานที่ต้องการทำได้ อีกทั้งยังสามารถใช้งานได้ร่วมกับ Node อื่นๆ ใน ROS อย่างสมบูรณ์แบบ ซึ่งทำให้มีความยืดหยุ่นและสามารถใช้งานกับงานต่างๆ ได้หลากหลายใน ROS
    - Instead of adding namespace manually to several nodes, one can use "GroupAction" to create a scope of the "launch" and use "PushRosNamespace" to add namespace to all subsequent nodes in the group.
      - แทนที่จะเพิ่ม namespace ด้วยตนเองให้กับโหนดหลายๆ โหนด ผู้ใช้สามารถใช้ "GroupAction" เพื่อสร้างขอบเขตของ "launch" และใช้ "PushRosNamespace" เพื่อเพิ่ม namespace ให้กับโหนดทั้งหมดในกลุ่มที่กำหนด ดังนั้นการใช้ "GroupAction" จะช่วยลดความซ้ำซ้อนในการกำหนด namespace และช่วยให้การเขียน launch file สะดวกมากยิ่งขึ้น
      
- Topic >> Launch Argument
  - Launch Argument เป็นเครื่องมือที่ใช้ในการส่งค่าตัวแปรหรือ parameter ให้กับโปรแกรมที่รันผ่าน launch file ใน ROS ซึ่งจะช่วยให้ผู้ใช้งานสามารถเปลี่ยนแปลงค่า parameter หรือตัวแปรต่างๆ ได้โดยไม่ต้องแก้ไขโปรแกรมโดยตรง

  - เมื่อผู้ใช้งานกำหนด Launch Argument ใน launch file โดยใช้คำสั่ง <arg> และระบุชื่อตัวแปร โปรแกรมที่รันผ่าน launch file จะสามารถอ่านค่าตัวแปรนั้นๆ ได้จาก environment variable ซึ่งจะถูกสร้างขึ้นโดยโปรแกรม ROS launch

  - การใช้ Launch Argument นั้นเป็นสิ่งสำคัญในการกำหนดค่า parameter หรือตัวแปรต่างๆ ให้กับโปรแกรม ROS โดยทั่วไปเมื่อเราต้องการรันโปรแกรมด้วยค่า parameter หรือตัวแปรที่แตกต่างกันในแต่ละครั้ง เราสามารถใช้ Launch Argument เพื่อสะดวกและรวดเร็วในการเปลี่ยนแปลงค่า parameter หรือตัวแปรต่างๆ ที่ต้องการใช้งานได้ในแต่ละครั้ง
    - Argument(s) can be assigned when launching a launch file.
      - ผู้ใช้งานสามารถกำหนด Argument ได้เมื่อรัน launch file โดยตัว Argument จะถูกกำหนดค่าเป็นตัวแปรเมื่อโปรแกรมรัน ซึ่งสามารถใช้ในการกำหนดค่า parameter หรือตัวแปรต่างๆ ให้กับโปรแกรมที่รันผ่าน launch file

      - การกำหนด Argument นั้นสามารถทำได้โดยระบุชื่อ Argument พร้อมกับค่าที่ต้องการให้กับ Argument นั้นๆ เมื่อรัน launch file โดยใช้คำสั่ง "ros2 launch" โดยอาจมี Argument หลายตัวที่ต้องการกำหนดค่าได้ในครั้งเดียว
    - Executable Arguments
    - Executable Arguments คือ วิธีการกำหนด Argument ให้กับ executable โดยตรง เพื่อใช้ในการรันโปรแกรมที่เรียกใช้งานจาก launch file โดยไม่ต้องผ่าน parameter server หรือ arguments ของ launch file

    - ใน ROS 2 สามารถกำหนด Executable Arguments ได้โดยใช้คำสั่ง "ros2 run" โดยระบุชื่อของ executable ตามด้วยชื่อ argument และค่าที่ต้องการกำหนดให้กับ argument นั้นๆ โดยใช้เครื่องหมาย "--" เป็นตัวคั่นระหว่างชื่อ argument และค่าที่ต้องการกำหนด
    - ROS2 Parameters
      - ROS2 Parameters เป็นวิธีที่ใช้ในการกำหนดค่าและการแชร์ค่าระหว่างโปรแกรมใน ROS 2 โดยที่ค่านั้นสามารถเปลี่ยนแปลงได้ระหว่างที่โปรแกรมกำลังทำงานอยู่

      - ROS2 Parameters จะถูกเก็บไว้ใน Parameter Server ซึ่งเป็นโครงสร้างข้อมูลที่ทำหน้าที่เป็นแหล่งเก็บค่าของตัวแปรต่างๆ ในระบบ ROS 2 โดย Parameter Server จะเก็บค่าในรูปแบบของ key-value pairs ซึ่ง key จะเป็นชื่อของ parameter และ value จะเป็นค่าของ parameter นั้นๆ

      - ROS2 Parameters สามารถกำหนดได้จากหลายแหล่ง เช่น launch file, command line arguments หรือโปรแกรมที่เขียนขึ้นมาเอง โดยในการกำหนด ROS2 Parameters จะใช้คำสั่ง rclcpp::Node::declare_parameter หรือ rclcpp::Node::declare_parameters ซึ่งใช้ในการกำหนด key และ default value ของ parameter นั้นๆ

      - นอกจากนี้ ROS2 Parameters ยังมีการรองรับการแชร์ค่าระหว่างโปรแกรมด้วยกัน ซึ่งสามารถทำได้โดยการเข้าถึง Parameter Server จากโปรแกรมอื่น ๆ โดยใช้ rclcpp::Node::get_parameter หรือ rclcpp::Node::get_parameters ซึ่งใช้ในการเรียกดูค่าของ parameter นั้นๆ โดยจะสามารถอ่านค่า parameter ที่ตั้งค่าไว้จากโปรแกรมอื่น ๆ ได้ และยังสามารถอัปเดตค่า parameter ได้ด้วย rclcpp::Node::set_parameters ซึ่งใช้ในการกำหนดค่าของ parameter นั้นๆ โดยใช้ key ของ parameter 
  - Adding Launch Arguments to the Launch file
    - การเพิ่ม Launch Argument เข้าไปใน Launch file ใน ROS2 สามารถทำได้โดยการกำหนดชื่อของ Argument และ default value ของ Argument นั้น ๆ ในไฟล์ XML ของ Launch file
    - DeclareLaunchArgument adds an ability to assign argument of the given name when launching.
      - DeclareLaunchArgument เป็นคำสั่งในไฟล์ Launch file ของ ROS2 ที่ใช้สำหรับการประกาศ Launch Argument โดยเพิ่มคุณสมบัติการกำหนดค่า Argument นั้น ๆ เมื่อเราเรียกใช้งาน Launch file นั้น ๆ ด้วย command line interface ของ ROS2 โดย DeclareLaunchArgument จะกำหนดชื่อของ Argument และค่า default value ของ Argument นั้น ๆ
    - LaunchConfiguration allows the Launch file to store and substitute value that is assigned to the variable.
      - LaunchConfiguration เป็นคลาสใน Launch file ของ ROS2 ที่ใช้สำหรับการเก็บค่าและการแทนที่ค่าที่กำหนดให้กับตัวแปร โดยค่านี้สามารถถูกกำหนดโดยผู้ใช้งานผ่าน command line interface ของ ROS2 หรือผ่านไฟล์ launch ต่าง ๆ ที่เราเขียนขึ้นมาได้

      - การใช้ LaunchConfiguration เพื่อกำหนดค่าสามารถทำได้โดยการสร้างออบเจ็กต์ LaunchConfiguration แล้วนำไปใช้กับตัวแปรที่ต้องการ
  - What if
    - Add both Launch arguments and Launch configurations 
      - เพื่อเพิ่ม Launch arguments และ Launch configurations ในไฟล์ Launch เราสามารถใช้คลาส DeclareLaunchArgument และ Substitution จากแพคเกจ launch ใน ROS2 ได้
    - Run turtlesim , kill the default turtle, and spawn leader and follower
      - เพื่อรัน turtlesim และสร้าง leader และ follower turtle
    - Modify the parameter file with the namespace
      - การแก้ไขไฟล์ Parameter ด้วย Namespace

      - ในการสร้างโปรแกรม ROS (Robot Operating System) แต่ละโปรแกรมจะต้องมีการกำหนดค่าต่าง ๆ สำหรับ Node (โปรแกรมย่อย) ต่าง ๆ ที่เกี่ยวข้องกับโปรแกรมหลัก โดยใช้ไฟล์ Parameter ซึ่งเป็นไฟล์ที่เก็บค่า default ของ Node แต่ละตัว

      - ในบางกรณี หากมี Node ที่มีชื่อเหมือนกัน แต่ต้องการกำหนดค่าต่าง ๆ ให้แตกต่างกัน สามารถใช้ Namespace เพื่อแยกค่า default ของ Node แต่ละตัวได้
    - Can we just turn Launch configuration to a string ?
      - ใช้ Launch Configuration เป็นสตริงได้หรือไม่?

       - ใน ROS (Robot Operating System) การสร้างและกำหนดค่าโปรแกรมโดยใช้ไฟล์ Launch Configuration มักจะเป็นวิธีการที่สะดวกและง่ายต่อการตั้งค่าโปรแกรม เนื่องจากไฟล์ Launch Configuration จะเก็บข้อมูลการกำหนดค่าของ Node แต่ละตัว รวมถึงการเชื่อมต่อ (Connection) ระหว่าง Node ที่เกี่ยวข้องกันไว้ด้วย

       - แม้ว่า Launch Configuration จะเป็นไฟล์ XML แต่ก็ไม่สามารถเปลี่ยนเป็นสตริงได้โดยตรง หากต้องการใช้ Launch Configuration เป็นสตริง จะต้องใช้ไลบรารีหรือโมดูลที่เขียนขึ้นมาเองเพื่อแปลง Launch Configuration ให้กลายเป็นสตริง
    - There is no function to convert LaunchConfiguration directly to string
      - ใน ROS (Robot Operating System) ไม่มีฟังก์ชันที่สามารถแปลง Launch Configuration เป็นสตริงได้โดยตรง การแปลง Launch Configuration เป็นสตริงนั้นต้องใช้โมดูลหรือไลบรารีเพิ่มเติมที่เขียนขึ้นมาเอง
      - ย่างไรก็ตาม มีโมดูล Python ชื่อ roslaunch2string ที่สามารถแปลง Launch Configuration เป็นสตริงได้
  - What is an OpaqueFunction
    - OpaqueFunction เป็นฟังก์ชันใน ROS (Robot Operating System) ที่ใช้สำหรับเรียกฟังก์ชันภายในไฟล์ Launch Configuration ซึ่งไม่ต้องการเรียกใช้ฟังก์ชันนั้นจากภายนอกไฟล์ Launch Configuration ได้ กล่าวคือ OpaqueFunction จะไม่สามารถเรียกใช้ได้จากภายนอกไฟล์ Launch Configuration หรือโปรแกรมอื่น ๆ
    - OpaqueFunction is a class defined in launch.actions. One can associate an OpaqueFunction with another function, which can access a Launch context (LaunchContext class from launch).
      - ข้อมูลนี้ไม่ถูกต้อง เนื่องจาก OpaqueFunction ไม่ใช่คลาสที่ถูกกำหนดไว้ใน launch.actions แต่เป็นอีกหนึ่งวิธีในการกำหนดฟังก์ชันในไฟล์ Launch Configuration ใน ROS (Robot Operating System)
      - เราไม่สามารถเชื่อม OpaqueFunction กับฟังก์ชันอื่น ๆ ได้ เนื่องจาก OpaqueFunction มีลักษณะเป็นฟังก์ชันที่ไม่สามารถเรียกใช้งานได้จากภายนอกไฟล์ Launch Configuration หรือโปรแกรมอื่น ๆ
    - One method of the class LaunchContext allows us to perform the substitution on any Launch configuration. This will convert the Launch configuration to Python string. However, this has to be done in the function. We will refer to this as “render_function”.
      - วิธีการเรียกใช้งาน Launch configuration เพื่อแปลงเป็นสตริงของ Python ใช้ฟังก์ชัน render_substitutions ซึ่งเป็นเมท็อดของคลาส LaunchContext ในโมดูล launch.substitutions
       - การใช้งาน render_substitutions จะต้องอยู่ในฟังก์ชัน ไม่สามารถเรียกใช้งานจากภายนอกได้ โดยต้องผ่าน LaunchContext เข้ามาใช้งาน
  - Applying OpaqueFunction
    - การใช้งาน OpaqueFunction ใน Launch file จะต้องกำหนด OpaqueFunction เป็น action ของ LaunchDescription โดยใช้คลาส ExecuteProcess และกำหนด cmd เป็น OpaqueFunction ที่ต้องการใช้งาน
    - This launch can take ‘dummy’ as an argument and can pass it along to other functions that use the string version of ‘dummy’.
      - เมื่อเราใช้ Launch file แล้วกำหนด argument เข้าไป แล้วส่งต่อไปยัง function อื่น ๆ ที่ใช้ Launch configuration ในรูปแบบของ Python string ได้แก่เหตุการณ์ที่เรียกว่า "substitution" ซึ่งจะทำให้เราสามารถส่งค่า arguments และ parameter ต่าง ๆ ไปยัง function อื่น ๆ ได้อย่างง่ายดาย
  - Whatwe have now
    - A Launch file that can run turtlesim_node, spawn the second turtle with a given name, run both via_point_follower, and turtle_follower. 
      - รัน turtlesim_node และ spawn ตัวเต่าที่สอง โดยกำหนดชื่อให้ตัวเต่าที่สอง จากนั้นเรียกใช้งาน turtlesim_node, via_point_follower และ turtle_follower พร้อมกับส่งค่า parameter ต่าง ๆ ผ่าน arguments ได้
    - It can take input arguments for spawn location and it can read parameters from a YAML file.
      - รับ input arguments เพื่อกำหนดตำแหน่ง spawn ตัวเต่าและอ่าน parameter จากไฟล์ YAML ได้
  - What if
    - If a turtlesim_node is already run, do we have to write a new Launch file that contains almost exactly the same thing ?
      - ไม่จำเป็นต้องเขียน Launch file ใหม่หากมี turtlesim_node ที่กำลังทำงานอยู่แล้ว สามารถเรียกใช้งาน turtlesim_node ที่กำลังทำงานอยู่ได้โดยการระบุชื่อ node นั้น ๆ ใน Command ของ ExecuteProcess ที่เกี่ยวข้อง
    - Can we modify the existing Launch file so that it can take a flag which tell the file whether to run a new turtlesim ?
      - ใช่ สามารถปรับแต่ง Launch file เพื่อรองรับการรัน turtlesim ใหม่โดยระบุ flag ได้
      - หากต้องการรองรับการรัน turtlesim ใหม่โดยมี flag ที่ชื่อว่า run_new_turtlesim สามารถเพิ่ม Parameter และ Condition ใน Launch file เพื่อตรวจสอบค่าของ run_new_turtlesim และเรียกใช้ turtlesim_node ตามที่ต้องการได้
  
- Topic >> Conditioning
  - Conditioning ในการพัฒนาซอฟต์แวร์คือการปรับปรุงโค้ดหรือโมดูลของโปรแกรมเพื่อให้มีความยืดหยุ่นและเป็นไปตามเงื่อนไขที่ต้องการ โดยทั่วไปแล้ว Conditioning มักเกี่ยวข้องกับการตรวจสอบเงื่อนไขของข้อมูล และการกำหนดการทำงานของโปรแกรมตามเงื่อนไขนั้นๆ

  - ใน ROS2, Conditioning เป็นเรื่องสำคัญที่ช่วยให้โปรแกรมสามารถทำงานได้อย่างเหมาะสมกับเงื่อนไขต่างๆ ที่อาจเกิดขึ้นในสภาพแวดล้อมหรือการทำงาน โดยเฉพาะเมื่อมีการทำงานร่วมกันของหลายๆ Node ใน ROS2 ซึ่งอาจต้องการตรวจสอบและปรับปรุงเงื่อนไขต่างๆ เพื่อให้การทำงานของระบบ ROS2 เป็นไปได้อย่างเหมาะสม ยืดหยุ่น และมีประสิทธิภาพ

  - เพื่อปรับปรุงการ Conditioning ใน ROS2 นักพัฒนาสามารถใช้เครื่องมือต่างๆ เช่น ROS Parameter, Launch File, ROS Action และ ROS Service เพื่อเพิ่มความยืดหยุ่นให้กับโปรแกรม และสามารถตรวจสอบและปรับปรุงเงื่อนไขต่างๆ ได้อย่างรวดเร็วและมีประสิทธิภาพ
  - Using IfCondition
    - IfCondition เป็นตัวเลือกที่นักพัฒนาสามารถใช้เพื่อปรับเปลี่ยนเงื่อนไขการทำงานของโปรแกรม ROS2 โดยอ้างอิงถึงค่า ROS Parameter หรือ Environment Variable ที่กำหนดไว้ในระบบ เมื่อ IfCondition ถูกใช้งาน โปรแกรม ROS2 จะตรวจสอบเงื่อนไขที่กำหนดไว้ และทำงานตามสถานะที่ได้รับค่า
    - Using IfCondition
      - การใช้งาน IfCondition สามารถนำมาใช้ในการกำหนดเงื่อนไขการทำงานของ Node, Topic, Service และ Action ของ ROS2 โดยสามารถกำหนดเงื่อนไขให้เป็น True หรือ False ด้วยการกำหนดค่า Parameter หรือ Environment Variable เพื่อควบคุมการทำงานของโปรแกรม ROS2 ให้เหมาะสมกับสภาพแวดล้อมหรือสถานการณ์ที่เกิดขึ้น
      - Although the Launch actions are added to the Launch description, they will only be executed if the condition is "True".
        - ข้อความดังกล่าวอาจเกี่ยวกับการใช้งาน IfCondition ในไฟล์ Launch description ของ ROS2 ซึ่งถูกใช้เพื่อควบคุมการเรียกใช้งาน Node, Topic, Service และ Action ของ ROS2 ให้เหมาะสมกับสภาพแวดล้อมหรือสถานการณ์ที่เกิดขึ้น
        - ในการกำหนด Launch action ให้ใช้งาน IfCondition ใน Launch description ของ ROS2 นักพัฒนาสามารถใช้ตัวแปรในรูปแบบ ROS Parameter หรือ Environment Variable ในการกำหนดเงื่อนไขที่ต้องการ

- Topic >> Printing/Logging in Launch file
  - การพิมพ์ข้อความหรือการเขียนลง log ใน Launch file ของ ROS2 เป็นการทำให้นักพัฒนาสามารถตรวจสอบสถานะและข้อมูลต่าง ๆ ของการทำงานของ Node, Topic, Service และ Action ที่กำลังทำงานอยู่ หรือเพื่อทำการ Debug ปัญหาที่เกิดขึ้นในระบบ

  - การทำการพิมพ์หรือ logging ใน Launch file ของ ROS2 สามารถทำได้โดยใช้ Launch action ของโปรแกรม Node ซึ่งสามารถกำหนด Argument เพื่อกำหนดโหมดการทำงานและข้อความที่ต้องการแสดงผลได้ โดยจะใช้ Argument ดังนี้
    - output : กำหนดโหมดการแสดงผลของ log โดยมีค่าเป็น "log" (default) หรือ "screen"
    - prefix : กำหนด prefix ของข้อความที่จะแสดงใน log
  - Logging information in Launch file
    - การบันทึกข้อมูลใน Launch file ใน ROS สามารถทำได้โดยใช้การ log message ซึ่งเป็นเครื่องมือที่ช่วยในการบันทึกข้อมูลต่าง ๆ ของโปรแกรม และช่วยในการติดตามเหตุการณ์ที่เกิดขึ้นในระบบ ROS ได้ง่ายขึ้น การ log message จะใช้คำสั่ง rospy.loginfo(), rospy.logwarn(), หรือ rospy.logerr() เพื่อบันทึกข้อความแสดงสถานะต่าง ๆ ของโปรแกรม

- Topic >> Launch filesin a Launch file
  - การเรียกใช้ Launch file ภายใน Launch file ใน ROS นั้นสามารถทำได้โดยการใช้ตัวอักษรพิเศษ $(find) เพื่ออ้างอิงไปยัง package และตำแหน่งของ Launch file ดังนั้นเราสามารถเรียกใช้ Launch file อื่น ๆ ภายใน Launch file เดียวกันได้
  - Calling another Launch file in a Launch file
    - การเรียกใช้ Launch file อื่น ๆ ใน Launch file ปัจจุบันสามารถทำได้โดยใช้ <include> element ซึ่งจะดึง Launch file อื่น ๆ เข้ามาใน Launch file ปัจจุบัน
    - Get full path of other Launch file
      - เพื่อเรียกใช้ Launch file จากตำแหน่งอื่น ๆ ที่ไม่ได้อยู่ใน package เดียวกัน จะต้องระบุตำแหน่งของ Launch file นั้นๆ โดยตรง โดยใช้เส้นทางสมบูรณ์ของ Launch file เช่น /home/user/catkin_ws/src/my_package/launch/my_program.launch
    - One can also pass along the arguments to other Launch file.
      - ในการโหลด Launch file จากตำแหน่งอื่น ๆ ใน Launch file ปัจจุบัน ยังสามารถส่ง argument ไปให้กับ Launch file นั้น ๆ ได้ด้วย โดยใช้ <arg> element

- Topic >> Scheduling in Launch File
  - การวางกำหนดการใน Launch File เป็นการกำหนดลำดับของการเรียกใช้ Node และเซตพารามิเตอร์ต่างๆ ของ Node ในการรันแต่ละ Node ใน ROS 2 โดยใช้ไฟล์ XML ที่เรียกว่า Launch File เพื่อแสดงกระบวนการใน ROS 2
  - การวางกำหนดการใน Launch File สามารถทำได้โดยใช้เครื่องหมาย "<group>" เพื่อรวม Node หลายๆ ตัวเข้าด้วยกันในกลุ่มเดียวกัน โดยเครื่องหมาย "<group>" จะทำให้ Node ที่อยู่ในกลุ่มเดียวกันถูกเรียกใช้พร้อมกัน
  - Running shell command using ExecuteProcess
    - การใช้งาน ExecuteProcess ในไฟล์ Launch ใช้สำหรับรันคำสั่ง shell หรือคำสั่งที่เป็นโปรแกรมภายนอก ซึ่งจะมีการรันคำสั่งที่กำหนดไว้เมื่อเปิด launch file จนกว่าคำสั่งนั้นจะเสร็จสิ้น
  - Event Handlers
    - การใช้งาน event handlers ในไฟล์ launch ของ ROS นั้นเป็นการจัดการกับเหตุการณ์ที่เกิดขึ้นในระหว่างการทำงานของการ launch ของ ROS เช่นเมื่อเริ่มต้น node หรือเมื่อมีการหยุดการทำงานของ node ใดๆ อีกตัวหนึ่ง เราสามารถใช้ event handlers เพื่อจัดการกับเหตุการณ์ดังกล่าวได้ ซึ่งมีหลายประเภทของ event เช่น process start, process exit, และ process output เป็นต้น
    - เพื่อกำหนด event handlers ในไฟล์ launch นั้น เราจะใช้ tag <event> โดยระบุชื่อของเหตุการณ์ที่ต้องการจัดการตามด้วย tag ที่เกี่ยวข้อง ตัวอย่างเช่น เพื่อจัดการกับ event ที่เกิดขึ้นเมื่อ node ได้เริ่มทำงาน
    - The state of launched processes is monitored by the Launch system and can be used to 
trigger "events".
      - ในระบบ Launch สามารถตรวจสอบสถานะของกระบวนการที่เริ่มใช้งานได้ โดยสามารถใช้งานสถานะนั้นเพื่อ trigger "events" ต่างๆ ได้ เช่น หากเราต้องการรัน Node A และ Node B พร้อมกัน แต่ Node B จะต้องรอให้ Node A เริ่มทำงานเสร็จก่อนถึงจะเริ่มทำงาน ในกรณีนี้ เราสามารถใช้ event เพื่อ trigger Node B เมื่อ Node A สามารถทำงานเสร็จสิ้นแล้ว โดยไม่ต้องรอให้เสร็จทั้งหมดก่อนที่จะเริ่ม Node B ด้วยการใช้ event handler ในระบบ Launch โดยเราสามารถกำหนดว่าเมื่อ Node A เริ่มทำงานสำเร็จแล้ว จะ trigger ให้ Node B เริ่มทำงานต่อไป
      - การใช้งาน event handler ทำได้โดยการกำหนด action ที่เกิดขึ้นเมื่อ event นั้นๆ ถูก trigger ขึ้นมา เช่น สามารถสั่งให้โปรแกรมหยุดทำงาน หรือเปลี่ยนค่าของตัวแปร หรืออื่นๆ ตามที่เราต้องการ
    - One can schedule Launch actions to execute when one of the following event occurs.
      - การส่งเหตุการณ์ (event) ใน Launch file สามารถทำได้
        - OnProcessStart
          - "OnProcessStart" เป็นเหตุการณ์หนึ่งใน Launch event handlers ที่สามารถใช้ในการกำหนดการทำงานที่จะถูกเรียกเมื่อกระบวนการ (process) ถูกเริ่มต้นโดย Launch file นั้น ๆ โดยจะใช้ข้อมูลเกี่ยวกับกระบวนการนั้นเพื่อดำเนินการต่อไป
        - OnProcessIO
          - "OnProcessIO" เป็นเหตุการณ์หนึ่งใน Launch event handlers ที่สามารถใช้ในการกำหนดการทำงานที่จะถูกเรียกเมื่อมีการอ่านข้อมูล (read) หรือเขียนข้อมูล (write) ผ่านสาย stdout หรือ stderr ของกระบวนการ (process) ที่ถูกเริ่มต้นโดย Launch file นั้น ๆ
        - OnExecutionComplete
          - "OnExecutionComplete" เป็นเหตุการณ์หนึ่งใน Launch event handlers ที่สามารถใช้ในการกำหนดการทำงานที่จะถูกเรียกเมื่อกระบวนการ (process) ที่ถูกเริ่มต้นโดย Launch file นั้น ๆ เสร็จสิ้นการทำงานเรียบร้อยแล้ว โดยไม่พบข้อผิดพลาดใด ๆ
        - OnProcessExit
          - เหตุการณ์ "OnProcessExit" จะถูกเรียกเมื่อกระบวนการ (process) ที่เปิดด้วยการใช้งาน ExecuteProcess สิ้นสุดลง (exit) โดยอาจจะสิ้นสุดด้วยการเสร็จสมบูรณ์ (completion) หรือมีข้อผิดพลาด (error) ก็ได้ การใช้งานเหตุการณ์นี้สามารถเพิ่ม Launch actions เพิ่มเติมหลังจากกระบวนการที่เรียกใช้ ExecuteProcess สิ้นสุดลงได้ หรือสามารถทำการเช็คสถานะของกระบวนการและทำงานตามสถานะนั้นๆ ได้อีกด้วย
        - OnShutdown
          - เหตุการณ์ "OnShutdown" จะถูกเรียกเมื่อกระบวนการ Launch ถูกสิ้นสุดลง (shut down) โดยอาจเกิดจากการเรียกใช้งานคำสั่ง Ctrl+C เพื่อหยุดการทำงานของ Launch หรือสามารถกำหนดให้เหตุการณ์นี้เป็นจุดสิ้นสุดของการทำงาน Launch ด้วยการกำหนด <exit> tag ใน Launch description การใช้งานเหตุการณ์นี้สามารถทำการทำความสะอาด (clean up) หรือบันทึกข้อมูลต่างๆ ก่อนที่ Launch จะสิ้นสุดลงได้
  - Common behaviors of ROS2 Nodes
    - พฤติกรรมที่พบบ่อยในโหนด ROS2 ประกอบด้วยดังนี้
       1. การตั้งค่าพารามิเตอร์: โหนด ROS2 สามารถรับค่าพารามิเตอร์จากไฟล์การกำหนดค่าหรือรับผ่านบริการเว็บเพจได้
       2.  การเผยแพร่และการสมัครฟังหัวข้อ (Topic): โหนด ROS2 สามารถเผยแพร่ข้อมูลหรือสมัครฟังหัวข้อ (Topic) เพื่อรับข้อมูลจากโหนดอื่น ๆ
       3.  การติดตามสถานะ: โหนด ROS2 สามารถติดตามสถานะของหัวข้อ (Topic) และบริการ (Service) ที่มันติดต่อกับได้
       4.  การใช้งานบริการ (Service): โหนด ROS2 สามารถเรียกใช้บริการของโหนดอื่นได้
       5.  การใช้งานและการแจ้งเหตุการณ์ (Action): โหนด ROS2 สามารถเรียกใช้และติดตามสถานะของการดำเนินการ (Action) ที่โหนดอื่นกำลังดำเนินการอยู่
       6.  การทำงานตามเวลา: โหนด ROS2 สามารถทำงานตามเวลาและตั้งค่าการแจ้งเตือนหรือส่งข้อมูลได้
       7.  การโพสต์ข้อความและการติดตามเหตุการณ์: โหนด ROS2 สามารถโพสต์ข้อความและติดตามเหตุการณ์ที่เกิดขึ้นในโหนด
       8.  การใช้งานประเภทข้อมูลที่กำหนดเอง: โหนด ROS2 สามารถใช้งานข้อมูลประเภทที่กำหนดเองด้วยการสร้างแพ็กเกจ (package) และการใช้งานข้อมูลเหล่านั้นในโปรแกรม
    - Often times, you want to run a node, configure some of its parameters, then activate the main functionality of the node. Sometimes, you want to take control and activate or deactivate it when you need it to. Sometimes, you might need the node to shut itself down after successfully complete a task.
      - บางครั้งเราต้องการให้โหนดทำงาน กำหนดค่าพารามิเตอร์บางส่วน แล้วเปิดใช้งานฟังก์ชันหลักของโหนด บางครั้งเราอาจต้องการควบคุมโหนดเองและเปิดหรือปิดใช้งานตามความต้องการ บางครั้งอาจต้องการให้โหนดปิดตัวเองหลังจากที่ทำงานเสร็จสิ้นอย่างประสบความสำเร็จ
    - These things can be implemented by using Finite State Machine or scheduling them in Launch file.
      - ในการทำงานของโหนด ROS2 บางครั้งเราอาจต้องการรันโหนด กำหนดค่าพารามิเตอร์บางส่วน แล้วเปิดใช้งานฟังก์ชันหลักของโหนด เราอาจต้องการควบคุมและเปิดหรือปิดการใช้งานโหนดเมื่อเราต้องการ บางครั้งเราอาจต้องการให้โหนดปิดตัวเองหลังจากทำงานเสร็จสิ้นเรียบร้อยแล้ว เหล่านี้สามารถปรับปรุงได้โดยใช้ Finite State Machine หรือการตั้งเวลาและควบคุมด้วย Launch file ทั้งสองวิธีนี้สามารถใช้งานได้ในการทำโหนด ROS2 ที่มีพฤติกรรมซับซ้อนและเป็นส่วนสำคัญในแอปพลิเคชัน ROS2 อย่างแพร่หลาย
    - However, ROS2 and rclpy already implemented these features for us
      - อย่างไรก็ตาม ROS2 และ rclpy ได้มีการออกแบบฟีเจอร์เหล่านี้ให้เราใช้งานอยู่แล้ว

- Topic >> Lifecycle Managed Node
  - Lifecycle Managed Node" หรือ "โหนดที่จัดการการดำเนินงานชีวิต" ใน ROS2 เป็นโหนดที่ออกแบบมาเพื่อทำให้ง่ายต่อการจัดการสถานะการทำงานของโหนด โดยเฉพาะอย่างยิ่งในกรณีที่ต้องการสั่งให้โหนดทำงานหรือหยุดการทำงานตามที่ต้องการ โหนดประเภทนี้สามารถรับสถานะการทำงานที่ต่างกันได้ เช่น สถานะเริ่มต้น (unconfigured) สถานะเตรียมการ (inactive) สถานะทำงาน (active) และสถานะหยุดการทำงาน (cleaningup) โดยจะมีฟังก์ชันเฉพาะที่ใช้สำหรับการเปลี่ยนสถานะการทำงานของโหนด อาทิเช่น configure เพื่อเปลี่ยนสถานะเป็น "unconfigured" activate เพื่อเปลี่ยนสถานะเป็น "active" หรือ cleanup เพื่อเปลี่ยนสถานะเป็น "cleaningup" ซึ่งทำให้ง่ายต่อการเขียนโค้ดและการจัดการสถานะการทำงานของโหนดใน ROS2
    - LifecycleNode is class provided by RCLPY. It is a sub-class of rclpy.Node with some additional features.
      - LifecycleNode เป็นคลาสที่ให้โดย RCLPY ซึ่งเป็นซับคลาสของ rclpy.Node โดยมีคุณสมบัติเพิ่มเติมบางอย่างให้กับโหนดนี้
    - The node has 4 possible states : unconfigured, inactive, active, finalized.
      - โหนดมีสถานะที่เป็นไปได้ 4 สถานะคือ : unconfigured, inactive, active, finalized
    - For the node to transit from one state to another state, it must be triggered by lifecycle interface or "lifecycle manager" that has lifecycle service clients.
      - เพื่อให้โหนดเปลี่ยนสถานะจากสถานะหนึ่งไปสู่สถานะอื่น ๆ จะต้องมีการเรียกใช้ Lifecycle interface หรือ "lifecycle manager" ที่มี lifecycle service clients มาช่วยในการเปลี่ยนสถานะของโหนดนั้น ๆ
  - State Machine inside LifecycleNode
    - สถานะของ LifecycleNode สามารถจัดการได้โดยใช้ Finite State Machine ซึ่งจะมีสถานะหลักๆ ดังนี้
      1.  configured : หลังจากสร้าง LifecycleNode แต่ยังไม่ได้ทำการปรับแต่งพารามิเตอร์ของ node
      2.  active : หลังจากทำการปรับแต่งพารามิเตอร์ของ node เรียบร้อยแล้ว แต่ยังไม่ได้เปิดใช้งาน node
      3.  active : หลังจากเปิดใช้งาน node เรียบร้อยแล้ว
      4.  finalized : หลังจากทำการปิดใช้งาน node
        - When doing on-function(), an error may occur. This will trigger onError()
          - เมื่อทำงานใน on_function() เกิดข้อผิดพลาด (error) อาจเกิดขึ้นได้ และจะทำให้เกิดการเรียกใช้งาน onError() ขึ้นมา
     -  การเปลี่ยนสถานะของ LifecycleNode จะต้องใช้งาน Lifecycle Interface หรือ Lifecycle Manager โดยการสร้าง Service Client เพื่อเรียกใช้งาน Lifecycle Service ที่เกี่ยวข้องกับการเปลี่ยนสถานะนั้นๆ
     - ใน LifecycleNode จะมี State Machine ซึ่งจะเปลี่ยนสถานะของ node ตามการเรียกใช้งาน Lifecycle Service จาก Lifecycle Manager ที่กำลังใช้งานอยู่ โดย LifecycleNode จะส่ง Event ที่เกี่ยวข้องกับ Lifecycle Service ไปยัง State Machine ของมันเพื่อเปลี่ยนสถานะของ node ตามที่ได้ระบุไว้ใน State Machine นั้น
  - rclpy LifecycleNode : (MinimalDocumentation)
    - โดยส่วนใหญ่แล้ว ROS 2 มีการจัดการ lifecycle ให้เราแล้วผ่าน rclcpp และ rclpy โดยมีการทำงานดังนี้
    - rclpy LifecycleNode เป็นคลาสที่สืบทอดมาจาก rclpy.Node และมีคุณสมบัติเพิ่มเติมเพื่อรองรับการจัดการ lifecycle ของโหนด
    - rclpy LifecycleNode จะมี state machine ซึ่งจะช่วยให้สามารถเปลี่ยนสถานะของโหนดได้ตาม lifecycle ที่กำหนดไว้ โดยสามารถทำได้ผ่าน lifecycle interface หรือ lifecycle manager ที่มี lifecycle service clients
    - มีสถานะในการทำงานของ rclpy LifecycleNode ทั้งหมด 4 สถานะ ได้แก่ unconfigured, inactive, active, และ finalized โดยการทำงานของ LifecycleNode จะเปลี่ยนสถานะจากสถานะนึงไปยังอีกสถานะหนึ่งโดยอัตโนมัติหลังจากที่ได้รับคำสั่งจาก lifecycle interface หรือ lifecycle manager และอาจจะต้องเปิดใช้งานโดยเรียก function เฉพาะตัว เช่น activate() หรือ deactivate() โดยตรง
    - นอกจากนี้ ยังมี method ต่าง ๆ ที่เกี่ยวข้องกับการจัดการ lifecycle อีกมากมาย เช่น create_lifecycle_publisher() เพื่อสร้าง publisher สำหรับ lifecycle events หรือ get_current_state() เพื่อเรียกดูสถานะปัจจุบันของโหนด และอื่น ๆ อีกมากมาย
  - Lifecycle Command line Interface
    - Lifecycle Command line Interface คือเครื่องมือสำหรับจัดการ Lifecycle Node ในการเปิด-ปิด-เปลี่ยนสถานะโหนด และตรวจสอบสถานะโหนด โดยจะใช้ command line interface ในการสั่งงาน โดยเครื่องมือ CLI จะใช้บริการและโค้ดในการควบคุม Lifecycle Manager ในการส่งคำสั่งไปยัง Lifecycle Node โดยเฉพาะ ซึ่งจะช่วยให้ผู้ใช้งานไม่ต้องเขียนโค้ดเพิ่มเติมเพื่อจัดการสถานะของโหนด แต่สามารถทำได้ผ่านเครื่องมือ CLI อย่างสะดวกและรวดเร็ว
  
- Topic >> Data Distribution Service
  - "Data Distribution Service" คือโครงสร้างการแลกเปลี่ยนข้อมูลแบบเรียลไทม์ที่ออกแบบมาสำหรับการสื่อสารระหว่างโปรแกรมของหน่วยประมวลผล (Process) หรือเครื่องคอมพิวเตอร์ที่ต่างกัน โดยการใช้งาน DDS จะมีการแลกเปลี่ยนข้อมูลในรูปแบบของ Topic หรือ Data Topic และมีการติดตามสถานะและการแจ้งเตือนสำหรับผู้รับ (Subscriber) และผู้ส่ง (Publisher) ด้วย Quality of Service (QoS) ที่ต่างกันได้ตามความต้องการของแต่ละแอพพลิเคชัน
  - DDS เป็นเทคโนโลยีที่เหมาะสำหรับการทำงานในระบบ Distributed System และ Real-time System ที่มีความต้องการในเรื่องของความเร็วในการส่งข้อมูลและความเสถียรภาพของระบบในการทำงาน
  - "Data Distribution Service" หรือ DDS เป็นเทคโนโลยีที่ใช้ในการแลกเปลี่ยนข้อมูลระหว่างระบบและอุปกรณ์ต่าง ๆ ในระบบ Distributed System ซึ่ง DDS เป็นมาตรฐานการสื่อสารที่ได้รับการพัฒนาขึ้นโดย OMG (Object Management Group) ซึ่งเป็นองค์กรที่มีภาระกิจในการพัฒนามาตรฐานเทคโนโลยีและมาตรฐานการสื่อสารระหว่างระบบ โดย DDS มีความสามารถในการจัดการและควบคุมการแลกเปลี่ยนข้อมูลอย่างมีประสิทธิภาพและมีความน่าเชื่อถือสูง
  - DDS มีโครงสร้างที่ประกอบด้วย 3 ส่วนหลัก คือ Data Writers, Data Readers และ Data Bus โดย Data Writers เป็นส่วนที่เป็นผู้ส่งข้อมูล ส่วน Data Readers เป็นผู้รับข้อมูล และ Data Bus เป็นตัวกลางที่ใช้ในการส่งข้อมูลระหว่าง Data Writers และ Data Readers
  - DDS มีหลักการทำงานแบบ Publish/Subscribe ซึ่งจะทำการแลกเปลี่ยนข้อมูลระหว่าง Data Writers และ Data Readers โดยผู้ส่งข้อมูลจะทำการ publish ข้อมูลไปยัง Data Bus และผู้รับข้อมูลจะทำการ subscribe ข้อมูลจาก Data Bus เพื่อรับข้อมูลที่ต้องการ
  - DDS มีความสามารถในการจัดการและควบคุมการส่งข้อมูลอย่างมีประสิทธิภาพ โดยสามารถจัดการและควบคุมความเร็วในการส่งข้อมูล ความน่าเชื่อถือในการส่งข้อมูล การจัดการข้อมูลที่ได้รับ และการจัดการการเชื่อมต่อระหว่างระบบและอุปกรณ์ต่าง ๆ อีกด้วย
  - Communication in ROS(1)
    - การสื่อสารใน ROS(1) จะใช้รูปแบบของ Message Passing โดยจะมีการส่งและรับข้อมูลระหว่าง Nodes ผ่านทางสื่อสารแบบ Topic ซึ่งเป็นช่องทางการสื่อสารข้อมูลระหว่าง Nodes และมีรูปแบบของข้อมูลที่ถูกกำหนดไว้ล่วงหน้า โดยในการส่งข้อมูลจะใช้ Publisher ในการแจ้งข้อมูลไปยัง Topic และ Subscriber จะรับข้อมูลจาก Topic นั้น ๆ และใช้ในการประมวลผลต่อไป
    - ในการสื่อสารระหว่าง Nodes ผ่านทาง Topic จะมีการแบ่งแยกเป็น 2 รูปแบบ คือ Point-to-Point Communication และ Broadcast Communication โดย Point-to-Point Communication จะมีการส่งข้อมูลจาก Node ผู้ส่งไปยัง Node ผู้รับเพียงคนเดียว ส่วน Broadcast Communication จะมีการส่งข้อมูลจาก Node ผู้ส่งไปยัง Node ผู้รับทั้งหมดที่ subscribe กับ Topic นั้น ๆ
    - นอกจากนี้ ROS(1) ยังมีการสื่อสารระหว่าง Nodes ผ่านทาง Service ซึ่งเป็นรูปแบบการสื่อสารแบบ Synchronous โดย Service Client จะส่ง Request ไปยัง Service Server และรอการตอบกลับจาก Server โดยจะมีการกำหนดรูปแบบของ Request และ Response ล่วงหน้า
    - การสื่อสารใน ROS(1) เป็นส่วนสำคัญที่จำเป็นต้องเข้าใจเพื่อใช้งาน ROS(1) ได้อย่างมีประสิทธิภาพและถูกต้อง
    - Transport Protocol
      - Transport Protocol หมายถึงโปรโตคอลที่ใช้ในการสื่อสารข้อมูลระหว่าง Nodes ใน ROS โดย ROS มี Transport Protocol อยู่ 2 แบบ คือ TCPROS และ UDPROS
      - TCPROS คือโปรโตคอลที่ใช้ TCP/IP ในการสื่อสารข้อมูลระหว่าง Nodes โดยมีการกำหนด Connection ระหว่าง Nodes และส่งข้อมูลผ่านทาง Connection นั้น ๆ โดยมีความเสถียรสูงและมีการตรวจสอบข้อผิดพลาดเมื่อมีการส่งข้อมูลผิดพลาด แต่มีปัญหาเรื่องการใช้งานทรัพยากรของระบบในการสร้าง Connection
      - UDPROS คือโปรโตคอลที่ใช้ UDP/IP ในการสื่อสารข้อมูลระหว่าง Nodes โดยไม่มีการกำหนด Connection ก่อนการส่งข้อมูล และส่งข้อมูลผ่านทาง Datagram โดยมีประสิทธิภาพสูงและมีการใช้งานทรัพยากรน้อยกว่า TCPROS แต่มีความไม่เสถียรสูงกว่า TCPROS เมื่อมีการส่งข้อมูลผิดพลาด
      - การเลือกใช้ Transport Protocol นั้นจะขึ้นอยู่กับลักษณะของงานที่ต้องการใช้งาน โดยในการเลือกใช้งานนั้นจะต้องพิจารณาถึงความเสถียรของการสื่อสาร ความเร็วในการส่งข้อมูล และปริมาณของข้อมูลที่ต้องการส่งข้าม Nodes ใน ROS
      - TCPROS
        - TCPROS คือโปรโตคอลในการสื่อสารข้อมูลระหว่าง Nodes ใน ROS โดยใช้ TCP/IP ในการเชื่อมต่อและส่งข้อมูล โดยมีขั้นตอนการทำงานดังนี้
          1.  Node ที่ต้องการส่งข้อมูลจะเปิด Connection ไปยัง Node ปลายทางที่ต้องการรับข้อมูล
          2.  Node ที่ต้องการรับข้อมูลจะรับ Connection จาก Node ส่งข้อมูล
          3.  Node ส่งข้อมูลจะส่งข้อมูลผ่านทาง Connection โดยแบ่งข้อมูลออกเป็น packet ขนาดเล็ก ๆ แล้วส่งไปยัง Node ปลายทาง
          4.  Node ปลายทางจะรับ packet ข้อมูลจาก Node ส่งข้อมูลแล้วนำมาเก็บไว้ใน buffer ของตัวเอง
          5.  เมื่อข้อมูลเต็มตัวถูกส่งมาถึง Node ปลายทางแล้ว จะมีการส่งข้อความยืนยันการรับข้อมูลกลับไปยัง Node ส่งข้อมูล เพื่อให้ Node ส่งข้อมูลสามารถส่ง packet ข้อมูลได้อีกครั้ง
          TCPROS มีความเสถียรสูงและมีการตรวจสอบข้อผิดพลาดเมื่อมีการส่งข้อมูลผิดพลาด แต่มีปัญหาเรื่องการใช้งานทรัพยากรของระบบในการสร้าง Connection
    - Discovery Center
      - Discovery Center หรือศูนย์ค้นหาเป็นส่วนหนึ่งของระบบ ROS ที่ใช้ในการค้นหา Nodes ที่มีอยู่ในระบบ โดยการค้นหานั้นจะใช้งานผ่าน Master Node ซึ่งเป็นตัวกลางในการจัดการ Nodes ต่าง ๆ ในระบบ
      - Discovery Center จะทำงานตลอดเวลาเพื่อตรวจสอบ Nodes ที่เข้าร่วมในระบบ ROS โดยการค้นหาจะมีการส่งคำขอ broadcast ออกไปทั้งหมดแล้วรอรับการตอบกลับจาก Nodes ที่ตอบกลับมา การตอบกลับนี้จะระบุข้อมูลเกี่ยวกับ Nodes ที่ตอบกลับมา เช่น ชื่อ Node, ประเภทของ Node และ URI ของ Node นั้น ๆ
      - Discovery Center เป็นส่วนที่สำคัญในการเชื่อมต่อระหว่าง Nodes ใน ROS เพราะช่วยให้การค้นหา Nodes เป็นไปอย่างมีประสิทธิภาพ และสามารถเชื่อมต่อ Nodes ต่าง ๆ ในระบบ ROS ได้อย่างรวดเร็วและมีประสิทธิภาพมากขึ้น
      - Using central discovery mechanism
        - การใช้กลไกค้นหาแบบกลาง (central discovery mechanism) เป็นวิธีที่ใช้ในการค้นหา Nodes ในระบบ ROS โดยการค้นหานั้นจะใช้ Master Node เป็นตัวกลางในการจัดการ Nodes ต่าง ๆ ในระบบ
        - การใช้กลไกค้นหาแบบกลางนี้ จะมีการลงทะเบียน Nodes กับ Master Node โดย Node จะทำการส่งข้อมูลเกี่ยวกับตนเองไปยัง Master Node เพื่อทำการลงทะเบียน ซึ่งข้อมูลเหล่านี้จะประกอบด้วย ชื่อ Node, ประเภทของ Node, URI ของ Node และค่าอื่น ๆ ที่เกี่ยวข้องกับ Node นั้น ๆ
        - เมื่อมีการค้นหา Node ใด ๆ ในระบบ ROS จะส่งคำขอไปยัง Master Node เพื่อขอข้อมูลเกี่ยวกับ Node ที่ต้องการค้นหา ซึ่ง Master Node จะตอบกลับด้วยข้อมูลเกี่ยวกับ Node นั้น ๆ โดยอ้างอิงจากข้อมูลที่ลงทะเบียนไว้กับตัวเอง จากนั้น Node ที่ต้องการค้นหาสามารถเชื่อมต่อกับ Node ที่ต้องการได้โดยตรงผ่าน URI ของ Node นั้น ๆ
        - การใช้กลไกค้นหาแบบกลางนี้มีประโยชน์มากในกรณีที่มี Nodes จำนวนมากในระบบ และการค้นหาต้องทำได้อย่างมีประสิทธิภาพและรวดเร็ว แต่ก็มีข้อเสียคือ การใช้ทรัพยากรของระบบมากขึ้นในการจัดการการลงทะเบียน Nodes กับ Master Node
  - The concept of ROS MASTER in ROS (1)
    - ROS MASTER เป็นส่วนหนึ่งของโครงสร้างของ ROS (1) ที่มีบทบาทสำคัญในการจัดการ Nodes และการเชื่อมต่อของ Nodes ในระบบ ROS
    - ROS MASTER เป็น Node ที่รันอยู่บนเครื่องคอมพิวเตอร์หนึ่งๆ และมีหน้าที่เป็นตัวกลางในการจัดการ Nodes ในระบบ ROS โดยจะทำหน้าที่รับผิดชอบในการจัดการการเชื่อมต่อของ Nodes ในระบบ ซึ่งการเชื่อมต่อนี้จะใช้แนวคิดของ Publisher-Subscriber หรือ Service ในการรับส่งข้อมูลระหว่าง Nodes
    - ในการเรียกใช้งาน ROS MASTER จะต้องรัน Node ชื่อ "roscore" ที่จะทำหน้าที่รัน ROS MASTER และให้บริการสำหรับ Nodes ทั้งหมดในระบบ ROS ในขณะที่ Nodes อื่น ๆ ในระบบ ROS จะเชื่อมต่อกับ ROS MASTER เพื่อทำการลงทะเบียนตัวเองและส่งข้อมูลต่าง ๆ ไปยัง ROS MASTER
    - การใช้งาน ROS MASTER นั้นเป็นการจัดการระบบที่มีประสิทธิภาพและมีความยืดหยุ่น โดยสามารถเชื่อมต่อ Nodes ใหม่ ๆ หรือเอาออกจากระบบได้โดยง่าย และยังสามารถตรวจสอบสถานะของ Nodes และการเชื่อมต่อได้ง่าย ทำให้เป็นตัวช่วยที่สำคัญในการพัฒนาระบบ Robotics และการค้นหาข้อผิดพลาดในการทำงานของ Nodes ในระบบ ROS ได้อย่างรวดเร็วและมีประสิทธิภาพ
  - Data Distribution Service is an Object Management Group machine-machine standard that aims to enable dependable, high-performance, interoperable, real-time, scalable data exchanges using a publish-subscribe pattern."
    - Data Distribution Service (DDS) เป็นมาตรฐานเครื่องมือช่วยการเชื่อมต่อแบบเครื่องจักรราบตามมาตรฐานของ Object Management Group (OMG) ซึ่งเน้นให้เกิดการแลกเปลี่ยนข้อมูลอย่างมั่นคง สูงสมราคา สามารถทำงานร่วมกันได้ และเป็นเรียลไทม์โดยใช้รูปแบบ publish-subscribe
    - DDS ถูกพัฒนาขึ้นเพื่อใช้ในการแลกเปลี่ยนข้อมูลในระบบ Real-time ที่มีความจำเป็นต้องมีการตอบสนองทันที ซึ่งมีการต้องการในงาน Robotics, Industrial Automation, และ Internet of Things (IoT) ที่ต้องการส่งข้อมูลระหว่างอุปกรณ์ได้อย่างรวดเร็ว มีประสิทธิภาพ และคงทนต่อความผิดพลาด
    - DDS มีรูปแบบการทำงานที่แตกต่างจากระบบการแลกเปลี่ยนข้อมูลแบบอื่น ๆ เช่น Message Queuing Telemetry Transport (MQTT) หรือ Advanced Message Queuing Protocol (AMQP) โดยมีขั้นตอนการทำงานดังนี้
      1.  Publisher จะสร้าง Topic และเผยแพร่ข้อมูลใน Topic นั้นๆ
      2.  Subscriber จะสมัครเป็น Subscriber ของ Topic นั้นๆ โดยมีการตั้งค่า Quality of Service (QoS) และระบุเงื่อนไขการรับข้อมูล
      3.  DDS จะเชื่อมต่อ Publisher และ Subscriber โดยใช้ Topic นั้นๆ ในการรับส่งข้อมูล โดยมีการควบคุมการเชื่อมต่อและการรับ-ส่งข้อมูลด้วย QoS
    - DDS เป็นการแลกเปลี่ยนข้อมูลแบบสนทนาแบบ Peer-to-Peer ที่มีประสิทธิภาพสูง และสามารถทำงานร่วมกันได้ในระบบที่มีความซับ
  -  ROS(1) vs. ROS2
    - ROS (1) และ ROS2 เป็น framework ที่มีความเกี่ยวข้องกับการพัฒนาระบบหุ่นยนต์และการควบคุมการทำงานของหุ่นยนต์ โดย ROS (1) เป็น version เดิมๆ ของ ROS ซึ่งเปิดตัวครั้งแรกในปี 2007 และมีการพัฒนาอย่างต่อเนื่องจนถึงปัจจุบัน ในขณะที่ ROS2 เป็นเวอร์ชันล่าสุดของ ROS ซึ่งเปิดตัวครั้งแรกในปี 2014
    - โดย ROS2 มีการปรับปรุงคุณสมบัติให้มีประสิทธิภาพสูงขึ้นในด้านการทำงานร่วมกับระบบ real-time และเครือข่ายมากขึ้น โดย ROS2 ใช้ DDS เป็นส่วนหนึ่งของโครงสร้างการทำงาน ซึ่งช่วยเพิ่มประสิทธิภาพในการแลกเปลี่ยนข้อมูล และมีการใช้งานร่วมกับหลายภาษาโปรแกรม อย่างไดนามิก ซึ่งช่วยให้มีความยืดหยุ่นในการเขียนโปรแกรม
    - นอกจากนี้ ROS2 ยังมีการพัฒนาเพื่อเพิ่มประสิทธิภาพในการทำงานร่วมกับระบบ real-time โดยการใช้งาน Real-time Executive for Multiprocessor Systems (RTEMS) และ Xenomai ซึ่งช่วยให้ ROS2 สามารถทำงานได้ในระบบ real-time ได้ดีกว่า ROS (1) โดยสามารถปรับแต่งการตั้งค่า QoS (Quality of Service) ให้เหมาะสมกับการใช้งานได้ง่ายขึ้น
    - ROS (1) และ ROS2 เป็น framework ที่เกี่ยวข้องกับการพัฒนาระบบหุ่นยนต์และการควบคุมการทำงานของหุ่นยนต์ โดย ROS (1) เป็น version เดิมๆ ของ ROS ซึ่งเปิดตัวครั้งแรกในปี 2007 และมีการพัฒนาต่อเนื่องจนถึงปัจจุบัน ในขณะที่ ROS2 เป็นเวอร์ชันล่าสุดของ ROS ซึ่งเปิดตัวครั้งแรกในปี 2014
    - ROS2 มีความแตกต่างจาก ROS (1) ในหลายด้าน แต่สิ่งที่เด่นที่สุดคือประสิทธิภาพการทำงานร่วมกับระบบ real-time ที่มีประสิทธิภาพสูงขึ้นมาก นอกจากนี้ ROS2 ยังเพิ่มความยืดหยุ่นในการเขียนโปรแกรม โดยรองรับหลายภาษาโปรแกรม เช่น Python, C++, และไดนามิก
    - ในเรื่องของการสื่อสารระหว่างโหนด ใน ROS (1) ใช้หลักการ XML-RPC และ TCPROS เพื่อส่งข้อมูลระหว่างโหนด ในขณะที่ ROS2 ใช้ DDS (Data Distribution Service) เป็นส่วนหนึ่งของโครงสร้างการทำงาน เพื่อช่วยเพิ่มประสิทธิภาพในการแลกเปลี่ยนข้อมูล โดยรองรับการตั้งค่า QoS (Quality of Service) ที่สามารถปรับแต่งได้ตามความต้องการของแต่ละโปรเจค
    - นอกจากนี้ ROS2 ยังมีฟีเจอร์ที่มากขึ้น อาทิเช่น การรองรับ real-time ผ่านการใช้งาน Real-time Executive for Multiprocessor Systems (RTEMS) และ Xenomai
  - Default ROS_DOMAIN_ID
    - ROS_DOMAIN_ID เป็นตัวกำหนดค่าเริ่มต้นสำหรับการใช้งานร่วมกันของ ROS2 โดยมีค่าเริ่มต้นเป็น 0 ซึ่งหมายถึงว่าไม่มีการกำหนด ROS_DOMAIN_ID โดยเฉพาะ แต่สามารถกำหนดค่า ROS_DOMAIN_ID ได้เพื่อใช้ในการกำหนดการทำงานของระบบ ROS2 ให้แตกต่างกันได้โดยอิสระ
    - ROS_DOMAIN_ID เป็นค่าที่ใช้สำหรับกำหนดโดเมนของ ROS2 ซึ่งจะช่วยให้โปรแกรม ROS2 ในโดเมนต่างๆสามารถแลกเปลี่ยนข้อมูลกันได้ โดยเราสามารถกำหนดค่า ROS_DOMAIN_ID เพื่อให้โปรแกรมที่ทำงานในโดเมนต่างๆ สามารถเชื่อมต่อกันและสื่อสารกันได้ โดย ROS_DOMAIN_ID จะมีค่าตั้งแต่ 0 ถึง 232-1 โดยจะไม่มีการใช้ค่าเริ่มต้นนี้ในโปรแกรม ROS2 ของเครื่องคอมพิวเตอร์เดียวกันในโดเมนเดียวกัน
    - การกำหนดค่า ROS_DOMAIN_ID สามารถทำได้โดยการกำหนดค่าในไฟล์ launch หรือเรียกใช้งานโดยตรงใน command line โดยใช้ option --ros-args --remap
  - Using ROS_DOMAIN_ID to separate operations
    - การใช้ ROS_DOMAIN_ID เพื่อแยกการดำเนินงาน หรือการแบ่งโดเมน (Domain) ใน ROS2 สามารถช่วยให้แต่ละโปรแกรมที่ทำงานใน ROS2 ภายใต้โดเมนต่าง ๆ สามารถแลกเปลี่ยนข้อมูลกันได้ โดยไม่ส่งผลกระทบกับโปรแกรมที่ทำงานในโดเมนอื่น ๆ ในระบบ ROS2 ที่เชื่อมต่อกันอยู่
    - การใช้ ROS_DOMAIN_ID นั้นสามารถใช้กับสถานการณ์ที่ต้องการแยกการดำเนินงานระหว่างโปรแกรมในระบบ ROS2 ได้หลากหลาย ยกตัวอย่างเช่น
    - การทดสอบ (Testing): การใช้ ROS_DOMAIN_ID เพื่อแยกการทดสอบของแต่ละชุด ที่อาจมีการทดสอบที่ต้องใช้ความแตกต่างในการกำหนดพารามิเตอร์หรือการตั้งค่าอื่น ๆ ในแต่ละชุด
    - การทำงานในสภาพแวดล้อมที่แตกต่างกัน: การใช้ ROS_DOMAIN_ID เพื่อแยกการทำงานของโปรแกรมในสภาพแวดล้อมที่แตกต่างกัน เช่น การใช้โปรแกรมในสภาพแวดล้อมทดสอบและการใช้โปรแกรมในสภาพแวดล้อมจริง
    - การทำงานในโมดูลหลายๆ ตัว: การใช้ ROS_DOMAIN_ID เพื่อแยกการทำงานของโปรแกรมในโมดูลหลายๆ ตัวที่มีความต้องการการเชื่อมต่อและการแลกเปลี่ยนข้อมูลกันกับโปรแกรมในโมดูลอื่น ๆ
    - การกำหนด ROS_DOMAIN_ID สามารถทำได้ในไฟล์ launch หรือเรียกใช้งานโดยตรงใน command line โดยใช้ option --ros-args
  - Simple Discovery Protocol (eProsima)
    - Simple Discovery Protocol (SDP) เป็นโปรโตคอลที่ถูกพัฒนาขึ้นโดย eProsima สำหรับการค้นหาโปรแกรมในระบบ ROS2 โดย SDP ใช้หลักการของ UDP multicast ในการค้นหาโปรแกรมและส่งข้อมูล Service และ Topic ให้กับโปรแกรมที่เป็นผู้รับ
    - SDP มีข้อดีต่อการใช้งานในระบบ ROS2 ดังนี้
      1.  ค้นหาโปรแกรมแบบ real-time: SDP สามารถค้นหาโปรแกรมที่มีการเชื่อมต่อและการแลกเปลี่ยนข้อมูลแบบ real-time ได้
      2.  ความเป็นมาตรฐาน: SDP เป็นโปรโตคอลที่มีการพัฒนาโดย eProsima ซึ่งเป็นผู้นำด้าน middleware ที่ใช้ในการพัฒนาโปรแกรม real-time และ IoT
      3.  การใช้งานง่าย: การใช้งาน SDP ง่ายเพราะมีการทำงานบน Layer ของ ROS2 ทำให้ไม่ต้องมีการติดตั้งและกำหนดค่าเพิ่มเติม
      4.  ความเสถียรและประสิทธิภาพ: SDP มีความเสถียรและประสิทธิภาพสูง เนื่องจากใช้ UDP multicast ในการส่งข้อมูลและมีการจัดการระดับเครือข่ายเพื่อลดการสูญเสียข้อมูล
    - สรุปมาดูกันนะคะว่า Simple Discovery Protocol (SDP) เป็นโปรโตคอลที่เหมาะสำหรับการค้นหาและแลกเปลี่ยนข้อมูลในระบบ ROS2 ด้วยความเร็วและความเสถียรสูง และเป็นมาตรฐานของ eProsima ที่นำไปใช้งานได้อย่างแม่นยำ ง่ายต่อการใช้งาน และเหมาะสำหรับการพัฒนา
  - Fast DDS Sever
    - Fast DDS Server เป็นโปรแกรม middleware ที่ใช้สำหรับการสื่อสารระหว่างโปรแกรมในระบบ ROS2 โดย Fast DDS Server เป็น implementation ของ Data Distribution Service (DDS) ซึ่งเป็นมาตรฐานของ OMG (Object Management Group) สำหรับการสื่อสารแบบ publish-subscribe ระหว่างโปรแกรมในระบบ real-time และ distributed systems
    - Fast DDS Server มีความสามารถที่สำคัญดังนี้
      1.  ประสิทธิภาพสูง: Fast DDS Server มีความเร็วในการส่งข้อมูลและการตอบรับที่สูง และมีการจัดการข้อมูลเพื่อลดการสูญเสียและการแยกส่วนข้อมูลที่ไม่เกี่ยวข้อง
      2.  การทำงานแบบ real-time: Fast DDS Server มีการจัดการความสามารถในการทำงานแบบ real-time โดยมีการกำหนดค่า latency และ bandwidth เพื่อให้สามารถรองรับการสื่อสารแบบ real-time ได้อย่างมีประสิทธิภาพ
      3.  ความเป็นมาตรฐาน: Fast DDS Server เป็น implementation ของมาตรฐาน DDS ที่ได้รับการพัฒนาโดย OMG ซึ่งเป็นมาตรฐานของการสื่อสารแบบ publish-subscribe ในระบบ real-time และ distributed systems
      4.  ความสามารถในการขยาย: Fast DDS Server มีความสามารถในการขยายเพื่อรองรับการใช้งานในระบบที่มีจำนวนโปรแกรมมากขึ้น โดยใช้งานร่วมกับเทคโนโลยีอื่น ๆ เช่น Kubernetes
    - Fast DDS Server เป็นโปรแกรม middleware ที่มีความสามารถที่สำคัญสำหรับการสื่อสารระหว่างโปรแกรมในระบบ ROS2 โดยเฉพาะในงาน real-time และ distributed systems และเป็น implementation ของมาตรฐาน DDS
  - Fast DDS Sever (Optimization)
    - Fast DDS Server เป็นโปรแกรม middleware ที่มีการเพิ่มประสิทธิภาพในการสื่อสารระหว่างโปรแกรมในระบบ ROS2 โดยมีการทำ optimization ต่าง ๆ เพื่อเพิ่มประสิทธิภาพและลดการใช้งานทรัพยากรของระบบ
      1.  Multithreading: Fast DDS Server มีการเปิดใช้งาน multithreading เพื่อเพิ่มประสิทธิภาพในการสื่อสารระหว่างโปรแกรม โดยการทำงานแบบ concurrent สามารถลดเวลาในการสื่อสารได้มาก
      2.  Memory Allocation: Fast DDS Server มีการจัดการ Memory Allocation ที่ดีเพื่อลดปัญหาเกี่ยวกับ memory leaks และ overhead ของการจัดการ memory ซึ่งสามารถช่วยลดการใช้งานทรัพยากรได้
      3.  Quality of Service: Fast DDS Server มีการเพิ่มประสิทธิภาพในการสื่อสารระหว่างโปรแกรมโดยการใช้ Quality of Service (QoS) ที่เหมาะสมกับการสื่อสารแบบ real-time โดยให้ความสำคัญกับความเร็วในการส่งข้อมูลและความเสถียรในการสื่อสาร
      4.  Message Compression: Fast DDS Server มีการใช้ compression algorithm เพื่อลดขนาดของ message ซึ่งสามารถช่วยลดการใช้งานทรัพยากรได้
      5.  Zero Copy: Fast DDS Server มีการใช้งาน Zero Copy ในการส่งข้อมูล ซึ่งสามารถลดการคัดลอกข้อมูลและลดการใช้งานทรัพยากรได้
    - โดยการทำ optimization ต่าง ๆ ที่ Fast DDS Server มีนั้นสามารถเพิ่มประสิทธิภาพและลดการใช้งานทรัพยากรของระบบได้อย่างมีประสิทธิภาพขึ้นในการสื่อสารระหว่างโปรแกรมในระบบ ROS2
  - Network ArchitectureusingMultiple FastDiscovery Server
    - การออกแบบเครือข่ายโดยใช้ Multiple Fast DDS Server เป็นการแบ่งโหลดของระบบ ROS2 ออกเป็นหลายๆ ส่วน โดยใช้ Fast DDS Server เพื่อจัดการกับการสื่อสารระหว่างโปรแกรมในแต่ละส่วนของระบบ
    - เราสามารถออกแบบเครือข่ายโดยใช้ Multiple Fast DDS Server ได้ดังนี้
      1.  การแบ่งแยกระหว่างความเร็วในการส่งข้อมูล (Bandwidth): ในกรณีที่ระบบมีการสื่อสารแบบ real-time และมีการส่งข้อมูลในปริมาณมาก สามารถแบ่งการใช้ bandwidth ของระบบออกเป็นหลายๆ ส่วน โดยใช้ Fast DDS Server ในแต่ละส่วน เพื่อให้การสื่อสารระหว่างแต่ละส่วนของระบบไม่มีการแย่งกันในการใช้งาน bandwidth
      2.  การแบ่งแยกหน้าที่ของระบบ (Roles): เราสามารถแบ่งหน้าที่ของระบบออกเป็นหลายๆ ส่วน และใช้ Fast DDS Server ในแต่ละส่วน เพื่อให้การทำงานของระบบไม่มีการแย่งกัน และสามารถจัดการกับปัญหาเชิงพื้นฐานได้ง่ายขึ้น
      3.  การแบ่งแยกโดเมน (Domain): เราสามารถใช้ Fast DDS Server ในแต่ละโดเมนของระบบ เพื่อให้การสื่อสารระหว่างโดเมนไม่มีการแย่งกัน และการทำงานของระบบมีความเรียบร้อยมากขึ้น
    - การใช้ Multiple Fast DDS Server สามารถช่วยเพิ่มประสิทธิภาพและความเรียบร้อยในการทำงานของระบบ ROS2 ได้อย่างมีประสิทธิภาพ
    - การใช้ Fast DDS Server หลายตัวสามารถนำมาใช้ในการสร้างเครือข่ายในรูปแบบ Network Architecture ที่มีการแบ่งเบาหน้าที่และลดโหลดของแต่ละตัว
    - โดยในการสร้างเครือข่ายด้วย Fast DDS Server หลายตัว จะมีการแบ่งหน้าที่ของแต่ละตัว โดยแต่ละตัวจะเป็น Fast DDS Server ที่เป็น Master ใน Domain ที่ต่างกัน เพื่อลดโหลดและเพิ่มประสิทธิภาพในการทำงาน
    - การใช้ Fast DDS Server หลายตัวนี้จะช่วยลดปัญหาเกี่ยวกับการสื่อสารแบบ Point-to-Point ที่อาจเกิดขึ้นในกรณีที่มี Node หลายตัวเชื่อมต่อกันในระบบ ROS2 ซึ่งสามารถทำให้เครือข่ายมีความเสถียรและมีประสิทธิภาพในการสื่อสารระหว่างโปรแกรมได้อย่างมีประสิทธิภาพและเป็นระบบที่ยืดหยุ่น สามารถขยายเครือข่ายได้ตามต้องการของผู้ใช้งาน
  - Quality of Service
    - Quality of Service (QoS) หมายถึง คุณภาพของการให้บริการในการสื่อสารระหว่างโปรแกรม หรือการแลกเปลี่ยนข้อมูลระหว่างโหนดใน ROS ซึ่งมีการกำหนด QoS ในการสื่อสารของ ROS 2 ที่ช่วยให้ผู้ใช้งานสามารถกำหนดและปรับเปลี่ยนคุณภาพของการให้บริการได้ตามต้องการ
    - QoS มีการกำหนดด้วยค่า parameter ต่าง ๆ เช่น reliability, durability, deadline, liveliness, bandwidth และอื่น ๆ ซึ่งสามารถกำหนดได้ในแต่ละ Topic โดยแต่ละ Topic สามารถมีการกำหนด QoS ได้อย่างอิสระตามความต้องการของแต่ละโปรแกรม
    - การกำหนด QoS ทำให้ผู้ใช้งานสามารถปรับแต่งการสื่อสารระหว่างโปรแกรมได้ตามความต้องการ เช่น การกำหนด reliability สูงจะทำให้ข้อมูลถูกส่งไปยังโหนดปลายทางได้แม่นยำและมั่นใจมากขึ้น หรือการกำหนด deadline ที่เหมาะสมจะทำให้ข้อมูลถูกส่งไปยังโหนดปลายทางทันเวลาที่กำหนดไว้ ซึ่งการใช้งาน QoS ทำให้การสื่อสารใน ROS 2 มีความเสถียรและมีประสิทธิภาพมากยิ่งขึ้น
    - QoS Profile consists of QoS policies that allows the user to tune the communication between nodes.
      - QoS Profile ประกอบด้วย QoS policies ที่ช่วยให้ผู้ใช้งานสามารถปรับแต่งการสื่อสารระหว่างโหนดได้ตามความต้องการ โดย QoS policies จะเป็นการกำหนดค่า parameter ต่าง ๆ เช่น reliability, durability, deadline, liveliness, bandwidth และอื่น ๆ ซึ่งมีการกำหนดไว้เรียบร้อยใน ROS 2
      - ผู้ใช้งานสามารถสร้าง QoS Profile ขึ้นมาเพื่อใช้ในการกำหนดค่า QoS policies ต่าง ๆ ที่เหมาะสมกับแต่ละ Topic หรือการสื่อสารระหว่างโปรแกรม เพื่อให้การสื่อสารมีความเสถียรและมีประสิทธิภาพมากยิ่งขึ้น
      - การใช้งาน QoS Profile ใน ROS 2 จะช่วยให้ผู้ใช้งานสามารถปรับแต่งการสื่อสารระหว่างโหนดได้ตามความต้องการของแต่ละโปรแกรม โดยสามารถกำหนด QoS policies ต่าง ๆ ให้เหมาะสมกับความต้องการของแต่ละ Topic หรือการสื่อสารระหว่างโปรแกรมได้ใน QoS Profile โดยเฉพาะ เพื่อให้การสื่อสารมีประสิทธิภาพและเสถียรมากยิ่งขึ้น
  - History & Depth
    - History ใน ROS 2 คือ จำนวนของข้อมูลที่ถูกเก็บไว้ใน memory โดยจะเก็บข้อมูลที่ได้รับมาในขณะที่โปรแกรมยังไม่ได้ subscribe ไปยัง Topic นั้น ๆ โดยจะกำหนดให้ใช้ค่า default คือ 10
    - Depth ใน ROS 2 คือ จำนวนของข้อมูลที่ถูกเก็บไว้ใน memory โดยจะเก็บข้อมูลที่ได้รับมาในขณะที่โปรแกรมได้ subscribe ไปยัง Topic นั้น ๆ โดยจะกำหนดค่าได้ตามต้องการ โดย default คือ 10
    - การกำหนดค่า History และ Depth จะช่วยให้การสื่อสารระหว่างโปรแกรมสามารถเก็บข้อมูลได้มากขึ้น และสามารถส่งข้อมูลกลับไปให้ subscriber ที่ยังไม่ได้ subscribe ได้ ทำให้การสื่อสารมีความเสถียรและเป็นไปได้ในทุกสถานการณ์
    - History
      - History ใน ROS คือ จำนวนของข้อมูลที่ถูกเก็บไว้ใน memory โดยจะเก็บข้อมูลที่ได้รับมาในขณะที่โปรแกรมยังไม่ได้ subscribe ไปยัง Topic นั้น ๆ โดยจะกำหนดให้ใช้ค่า default คือ 1000
      - การกำหนดค่า History จะช่วยให้การสื่อสารระหว่างโปรแกรมสามารถเก็บข้อมูลได้มากขึ้น และสามารถส่งข้อมูลกลับไปให้ subscriber ที่ยังไม่ได้ subscribe ได้ ทำให้การสื่อสารมีความเสถียรและเป็นไปได้ในทุกสถานการณ์
    - Depth
      - Depth ใน ROS คือ จำนวนของข้อมูลที่ถูกเก็บไว้ใน memory โดยจะเก็บข้อมูลที่ได้รับมาในขณะที่โปรแกรมได้ subscribe ไปยัง Topic นั้น ๆ โดยจะกำหนดค่าได้ตามต้องการ โดย default คือ 1
      - การกำหนดค่า Depth จะช่วยให้การสื่อสารระหว่างโปรแกรมสามารถเก็บข้อมูลได้มากขึ้น และสามารถส่งข้อมูลกลับไปให้ subscriber ที่ยังไม่ได้ subscribe ได้ ทำให้การสื่อสารมีความเสถียรและเป็นไปได้ในทุกสถานการณ์
  - Reliability
    - Reliability ใน ROS หมายถึง ความเชื่อถือได้ในการส่ง-รับข้อมูลระหว่าง Node ซึ่งสามารถกำหนดได้ผ่านการตั้งค่า Quality of Service (QoS) โดยจะให้ผลการส่ง-รับข้อมูลที่แม่นยำและมีประสิทธิภาพในการทำงาน โดยสามารถกำหนด QoS ให้กับ Topic ที่ต้องการใช้งานได้ เช่น QoS ที่มีความเชื่อถือได้สูงกว่าจะทำให้การสื่อสารระหว่าง Node มีประสิทธิภาพและเสถียรมากขึ้น
    - การกำหนด QoS สามารถทำได้โดยใช้ API ที่มีอยู่ใน ROS ซึ่งสามารถกำหนดค่าได้หลากหลาย เช่น reliability, durability, deadline, liveliness และอื่น ๆ ที่สามารถกำหนดค่าได้ตามความต้องการของแต่ละ Node ในการสื่อสารกัน
    - Best Effort (similar to UDP)
      - Best Effort ใน ROS คล้ายกับการส่งข้อมูลแบบ UDP ซึ่งไม่มีการส่งสัญญาณการยืนยันการรับข้อมูลกลับมา เนื่องจากไม่ได้ใช้การยืนยันการรับข้อมูล (acknowledgement) จึงไม่สามารถรับรองได้ว่าข้อมูลที่ส่งไปนั้นถูกส่งถึงและรับได้จริง อย่างไรก็ตาม การใช้งาน Best Effort นั้นจะทำให้การส่ง-รับข้อมูลเร็วและมีประสิทธิภาพมากขึ้น แต่อาจมีความไม่เสถียร หรือข้อมูลส่งไม่ถึงแก่ผู้รับ
      - การใช้งาน Best Effort ใน ROS สามารถกำหนดได้ผ่านการตั้งค่า QoS ซึ่งจะเป็นการกำหนดค่า reliability เป็น "best effort" ซึ่งจะไม่มีการใช้งานการยืนยันการรับข้อมูล และข้อมูลส่งไปหา Node อื่นๆ จะไม่มีการแนะนำให้ใช้งานโดยตรงแต่อาจจะใช้ในกรณีที่ต้องการส่งข้อมูลด้วยความเร็วสูง และไม่จำเป็นต้องมีการรับรองความถูกต้องของข้อมูลที่ถูกส่ง
      - Attempt to send message, willskip the message if there is a problem (streaming type of data like laserscan or images)
        - การส่งข้อมูลแบบ Streaming เช่น ข้อมูลจากเซ็นเซอร์เลเซอร์สแกนหรือรูปภาพ อาจมีปัญหาในการส่งข้อมูลเนื่องจากขนาดของข้อมูลมีขนาดใหญ่และต้องใช้เวลาในการส่งข้อมูลนาน เพื่อลดปัญหาในการส่งข้อมูลแบบ Streaming ที่จะส่งข้อมูลที่มีขนาดใหญ่ไปยังโหนดปลายทาง โดยที่ไม่ต้องสนใจถึงสถานะของการส่งข้อมูลนั้นว่าสามารถส่งได้หรือไม่ การส่งข้อมูลแบบ Streaming ใน ROS จะใช้วิธีการตรวจสอบสถานะการส่งข้อมูลก่อน หากสถานะเป็นบวก (positive) จะส่งข้อมูลไปยังโหนดปลายทาง แต่หากสถานะเป็นลบ (negative) จะข้ามข้อมูลนั้นไปและไม่ส่ง
        - เพื่อลดปัญหาในการส่งข้อมูลแบบ Streaming ใน ROS ผู้ใช้สามารถปรับแต่งการส่งข้อมูลโดยกำหนดขนาดของข้อมูลที่จะส่ง รวมถึงการกำหนดอัตราการส่งข้อมูล อีกทั้งยังสามารถเลือกการใช้งานของการส่งข้อมูลแบบ Best Effort หรือ Reliable ซึ่งจะช่วยลดปัญหาในการส่งข้อมูลที่มีขนาดใหญ่ และช่วยให้การส่ง-รับข้อมูลมีประสิทธิภาพมากยิ่งขึ้น
    - Reliable (similar to TCP)
      - Reliable เป็นค่า QoS policy ที่คล้ายกับ TCP โดยจะทำการส่งข้อมูลแบบอย่างย่อหน้าและมีการตรวจสอบการส่งข้อมูลเพื่อให้แน่ใจว่าข้อมูลถูกส่งไปถึงผู้รับแล้วและถูกต้องตามที่ผู้ส่งต้องการ การใช้ค่า QoS policy นี้จะเหมาะสำหรับข้อมูลที่ต้องการความน่าเชื่อถือสูง เช่น การส่งข้อมูลจากเซนเซอร์หรืออุปกรณ์ที่ใช้ในการควบคุมที่ต้องการความแม่นยำและไม่สามารถรับข้อมูลที่สูญหายได้
